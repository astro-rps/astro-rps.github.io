{"version":"1","records":[{"hierarchy":{"lvl1":"Welcome to the Astro Research Preparation Series!"},"type":"lvl1","url":"/intro","position":0},{"hierarchy":{"lvl1":"Welcome to the Astro Research Preparation Series!"},"content":"","type":"content","url":"/intro","position":1},{"hierarchy":{"lvl1":"Welcome to the Astro Research Preparation Series!","lvl2":"Lecture 1: UNIX, Filesystems, Environments, and the Python Ecosystem"},"type":"lvl2","url":"/intro#lecture-1-unix-filesystems-environments-and-the-python-ecosystem","position":2},{"hierarchy":{"lvl1":"Welcome to the Astro Research Preparation Series!","lvl2":"Lecture 1: UNIX, Filesystems, Environments, and the Python Ecosystem"},"content":"\n\n","type":"content","url":"/intro#lecture-1-unix-filesystems-environments-and-the-python-ecosystem","position":3},{"hierarchy":{"lvl1":"Welcome to the Astro Research Preparation Series!","lvl3":"Preface: Some things to keep in mind over the next nine weeks","lvl2":"Lecture 1: UNIX, Filesystems, Environments, and the Python Ecosystem"},"type":"lvl3","url":"/intro#preface-some-things-to-keep-in-mind-over-the-next-nine-weeks","position":4},{"hierarchy":{"lvl1":"Welcome to the Astro Research Preparation Series!","lvl3":"Preface: Some things to keep in mind over the next nine weeks","lvl2":"Lecture 1: UNIX, Filesystems, Environments, and the Python Ecosystem"},"content":"\n\nCoding is tough!\n\nLearning how to code is like learning a new language. It takes a long time to become comfortable, and the more you practice coding the easier it gets!\n\nWe are a community\n\nWe want this to be a space where we all feel comfortable speaking up, asking questions, and sharing ideas. All of the instructors learned from each other while preparing for this series (because, as per point 1, coding is tough), and we want that same spirit of community learning to be upheld in this space!\n\nWe are learning data science\n\nComputer science is a broader discipline that encompasses the study of algorithms, software engineering, operating systems, and more, while data science is focused on extracting insights from data (observational or simulated) using a combination of computer science, statistics, and domain-specific knowledge.\n\nToday, we are not doing Python! We will start with Python next week!\n\n","type":"content","url":"/intro#preface-some-things-to-keep-in-mind-over-the-next-nine-weeks","position":5},{"hierarchy":{"lvl1":"Welcome to the Astro Research Preparation Series!","lvl3":"Lesson Agenda","lvl2":"Lecture 1: UNIX, Filesystems, Environments, and the Python Ecosystem"},"type":"lvl3","url":"/intro#lesson-agenda","position":6},{"hierarchy":{"lvl1":"Welcome to the Astro Research Preparation Series!","lvl3":"Lesson Agenda","lvl2":"Lecture 1: UNIX, Filesystems, Environments, and the Python Ecosystem"},"content":"Intro + Preface: Done!\n\nFilesystems, UNIX, and Terminal\n\nQuestion Break\n\nInstalling Python + Virtual Environments","type":"content","url":"/intro#lesson-agenda","position":7},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data"},"type":"lvl1","url":"/unix","position":0},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data"},"content":"","type":"content","url":"/unix","position":1},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"What is a Filesystem?"},"type":"lvl3","url":"/unix#what-is-a-filesystem","position":2},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"What is a Filesystem?"},"content":"A filesystem is a way of organizing and storing data on a computer. It provides a structure for how data is stored and accessed. In the context of your computer, think of it as a file cabinet where you organize and store your files. Each file is stored in a specific location known as a directory or folder.\n\n","type":"content","url":"/unix#what-is-a-filesystem","position":3},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Directories and Folders","lvl3":"What is a Filesystem?"},"type":"lvl4","url":"/unix#directories-and-folders","position":4},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Directories and Folders","lvl3":"What is a Filesystem?"},"content":"On macOS, you might be familiar with the Finder application, which allows you to navigate through directories and see the contents of your computer’s filesystem in a graphical way. Directories, also known as folders, are containers that hold files or other directories.\n\nIn the example above, “Documents” is a directory that can contain multiple files. Understanding the concept of directories is crucial for organizing and managing your data, especially in research.\n\nFinder is not enough\n\nIn research, you eventually find that simply using user friendly interfaces like Finder to navigate through your filesystems will not be enough. There are many reasons we might need something more that will be explained throughout this tutorial! To give one example, sometimes applications will need to be installed from command line rather than having an easy installer for you to use.\n\n","type":"content","url":"/unix#directories-and-folders","position":5},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Enter: UNIX and Terminal"},"type":"lvl3","url":"/unix#enter-unix-and-terminal","position":6},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Enter: UNIX and Terminal"},"content":"UNIX is a powerful and versatile operating system that has been widely used in scientific computing, including astronomy and data science. It provides a command-line interface (CLI; also called the shell or the terminal) for interacting with the computer’s operating system. While modern versions of UNIX, such as Linux, macOS, and others, have evolved, they still retain the core principles and commands that originated with the original UNIX system.\n\nThe terminal is a text-based interface that allows users to interact with their computer’s operating system by typing commands. Unlike graphical user interfaces (GUIs) like Finder, which use visual elements like windows and buttons, the terminal relies on text commands.\n\nA note on terminology:\n\nOperating Systems: UNIX, Linux, macOS, Windows, Debian\n\nCLIs: Command line, terminal, shell (specific CLI)\n\nShell Languages: bash, zsh\n\n","type":"content","url":"/unix#enter-unix-and-terminal","position":7},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Key Components of the Terminal:"},"type":"lvl3","url":"/unix#key-components-of-the-terminal","position":8},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Key Components of the Terminal:"},"content":"Prompt: The prompt displays information about the system’s current state and awaits your command.\n\nCommand Line: This is where you input commands. You type a command and press Enter to execute it.\n\nOutput: After executing a command, the terminal provides output, displaying information or responses from the system.\n\nIn practice, your default mac terminal might look something like this:\n\n\n\nNote\n\nYou can also customize your terminal display to look nicer! I’m happy to help provide some tips and tricks on customizing your terminal at a later time, but you should also try it out for yourself!\n\n","type":"content","url":"/unix#key-components-of-the-terminal","position":9},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Anatomy of a UNIX Command:"},"type":"lvl3","url":"/unix#anatomy-of-a-unix-command","position":10},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Anatomy of a UNIX Command:"},"content":"Understanding the anatomy of a UNIX command is crucial for effectively using the command line. Let’s break down the key components: command, options/flags, and arguments.\n\nA UNIX command typically follows the structure:command [options/flags] [arguments]\n\nCommand:\n\nThe primary action you want the computer to perform.\n\nExamples: ls, cd, cp, mv, echo, etc.\n\nOptions/Flags:\n\nFlags modify the behavior of the command.\n\nUsually preceded by a hyphen (-) or double hyphen (--).\n\nExamples: -l, -a, --verbose, --force, etc.\n\nArguments:\n\nThe entities upon which the command acts.\n\nCan be file names, directories, strings, etc.\n\nExamples: file.txt, directory/, string, etc.\n\n","type":"content","url":"/unix#anatomy-of-a-unix-command","position":11},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Example Commands:","lvl3":"Anatomy of a UNIX Command:"},"type":"lvl4","url":"/unix#example-commands","position":12},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Example Commands:","lvl3":"Anatomy of a UNIX Command:"},"content":"Basic Command:ls\n\nCommand: ls\n\nOptions/Flags: None\n\nArguments: None\n\nCommand with Options:ls -l\n\nCommand: ls\n\nOptions/Flags: -l\n\nArguments: None\n\nCommand with Arguments:cp file.txt backup/\n\nCommand: cp\n\nOptions/Flags: None\n\nArguments: file.txt, backup/\n\n","type":"content","url":"/unix#example-commands","position":13},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Common UNIX Commands"},"type":"lvl3","url":"/unix#common-unix-commands","position":14},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Common UNIX Commands"},"content":"","type":"content","url":"/unix#common-unix-commands","position":15},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"1. pwd - Print Working Directory","lvl3":"Common UNIX Commands"},"type":"lvl4","url":"/unix#id-1-pwd-print-working-directory","position":16},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"1. pwd - Print Working Directory","lvl3":"Common UNIX Commands"},"content":"The pwd command is used to print the current working directory, which is the directory you are currently in within the file system.pwd\n\nThis command will display the full path to the current directory.\n\n","type":"content","url":"/unix#id-1-pwd-print-working-directory","position":17},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"2. ls - List Files","lvl3":"Common UNIX Commands"},"type":"lvl4","url":"/unix#id-2-ls-list-files","position":18},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"2. ls - List Files","lvl3":"Common UNIX Commands"},"content":"The ls command is used to list the files and directories in the current directory.ls\n\nThis command provides a simple listing of the files and directories in the current location.\n\n","type":"content","url":"/unix#id-2-ls-list-files","position":19},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"3. cd - Change Directory","lvl3":"Common UNIX Commands"},"type":"lvl4","url":"/unix#id-3-cd-change-directory","position":20},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"3. cd - Change Directory","lvl3":"Common UNIX Commands"},"content":"The cd command is used to change the current working directory. You can move to a different directory by specifying the path.cd /path/to/directory\n\nUse cd .. to move up one level in the directory hierarchy.\n\nExercise One: Using Terminal\n\nIn your shell/terminal (Terminal on Mac, Ubuntu on WSL), try\n\ncd .\n\ncd ..\n\ncd ...\n\nWhat do you think each of these do (without looking it up)? Now try\n\nls -l\n\nls -a\n\nWhat do you think these are doing?\n\nUnderstanding and practicing these basic commands will give you the foundation to navigate and interact with the file system using the UNIX command line. As we progress in the workshop, we’ll explore more advanced commands and concepts.\n\n","type":"content","url":"/unix#id-3-cd-change-directory","position":21},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl2":"Why are we doing this?"},"type":"lvl2","url":"/unix#why-are-we-doing-this","position":22},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl2":"Why are we doing this?"},"content":"Open Question\n\nNow, that you have seen a bit of what UNIX + terminal can do, can you think of any reasons why understanding how to use these tools is useful for astronomy research?\n\n","type":"content","url":"/unix#why-are-we-doing-this","position":23},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"1. Organizing Data","lvl2":"Why are we doing this?"},"type":"lvl4","url":"/unix#id-1-organizing-data","position":24},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"1. Organizing Data","lvl2":"Why are we doing this?"},"content":"When you conduct research, you often work with large datasets and various files. Knowing how to navigate through directories using the command line is essential. Let’s say you have to migrate a bunch of data files into a different location on your computer. You can use the following commands:\n# Create a subdirectory to organize the files\nmkdir data_files\n\n# Move all files with a specific extension (e.g., .txt) into the subdirectory\nmv *.txt data_files/\n\n\nThe mkdir data_files command creates a new subdirectory named “data_files” in the current directory. Then the mv *.txt data_files/ command moves all files with the extension “.txt” into the “data_files” subdirectory. There are lots of different ways you can change these commands to move your data in different ways:\n\nyou can customize the file extension based on your specific data files\n\nyou can specify arbitrary folders to move files between rather than using the current directory\n\nyou could use keywords in the filenames to select files rather than their extensions\n\nUNIX commands are incredibly flexible and can become incredibly complicated. There will almost always be a solution your specific problem!\n\n","type":"content","url":"/unix#id-1-organizing-data","position":25},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"2. Navigating to Data in your Code","lvl2":"Why are we doing this?"},"type":"lvl4","url":"/unix#id-2-navigating-to-data-in-your-code","position":26},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"2. Navigating to Data in your Code","lvl2":"Why are we doing this?"},"content":"Understanding filesystems becomes crucial when writing code. Your code will not know where your data lives unless you tell it. If your code throws an error like “File not found” or “No such file or directory,” it’s often because the file is not in the specified directory (or there’s a typo in the file name).\n\nYou will see examples of specifying the path to the data once we start working with Python in the coming weeks!\n\n","type":"content","url":"/unix#id-2-navigating-to-data-in-your-code","position":27},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"3. Executing Code, Managing Dependencies, Version Control, and More!","lvl2":"Why are we doing this?"},"type":"lvl4","url":"/unix#id-3-executing-code-managing-dependencies-version-control-and-more","position":28},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"3. Executing Code, Managing Dependencies, Version Control, and More!","lvl2":"Why are we doing this?"},"content":"Understanding UNIX + Filesystems is important for many many more aspects of research beyond data management! We can’t get into all of these now, but as a preview:\n\nWhen we want to ``execute\" python code, we can do it from command line\n\nWhen we want to remotely operate another computer (for instance, at a telescope or a supercomputer cluster)\n\nWhen we want to manage code installations + packages\n\n","type":"content","url":"/unix#id-3-executing-code-managing-dependencies-version-control-and-more","position":29},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl2":"Text Editors: Vim and Nano"},"type":"lvl2","url":"/unix#text-editors-vim-and-nano","position":30},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl2":"Text Editors: Vim and Nano"},"content":"\n\n","type":"content","url":"/unix#text-editors-vim-and-nano","position":31},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Vim","lvl2":"Text Editors: Vim and Nano"},"type":"lvl3","url":"/unix#vim","position":32},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Vim","lvl2":"Text Editors: Vim and Nano"},"content":"Vim (Vi Improved) is a powerful and highly configurable text editor that is widely used in the programming community. It operates in different modes, allowing users to navigate, edit, and manipulate text efficiently. Vim has a steeper learning curve, but its super versatile and its my favorite.","type":"content","url":"/unix#vim","position":33},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Basic Vim Commands","lvl3":"Vim","lvl2":"Text Editors: Vim and Nano"},"type":"lvl4","url":"/unix#basic-vim-commands","position":34},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Basic Vim Commands","lvl3":"Vim","lvl2":"Text Editors: Vim and Nano"},"content":"Normal Mode: Used for navigating and manipulating text. You start in normal mode, and can press Esc to return to normal mode.\n\nh, j, k, l, or arrow keys: Move left, down, up, and right, respectively.\n\ndd: Delete a line.\n\nyy: Copy a line.\n\np: Paste the copied or deleted text.\n\nInsert Mode: Used for inserting or editing text. Press i to enter Insert Mode.\n\nYou can type to insert your desired text.\n\nVisual Mode Used for selecting text. Press v to enter Visual Mode.\n\nYou can select blocks of text (to copy/cut/paste different amounts of text)\n\nSpecial sub-modes: visual line mode (V) or visual block mode (<C-V>)\n\nCommand Mode: Used for executing commands. : to enter command mode.\n\n:w: Save changes.\n\n:q: Quit Vim (without changes) or :q! to force quit and delete unsaved changes\n\n:wq or :x or ZZ: Save and quit.\n\nYou can also do cool things like find and replace in this mode!\n\n","type":"content","url":"/unix#basic-vim-commands","position":35},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Nano","lvl2":"Text Editors: Vim and Nano"},"type":"lvl3","url":"/unix#nano","position":36},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Nano","lvl2":"Text Editors: Vim and Nano"},"content":"Nano is a straightforward and user-friendly text editor that is beginner-friendly. It provides a simple interface for editing text files and is particularly suitable for quick edits or when a full-featured editor like Vim might be overwhelming.","type":"content","url":"/unix#nano","position":37},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Basic Nano Commands","lvl3":"Nano","lvl2":"Text Editors: Vim and Nano"},"type":"lvl4","url":"/unix#basic-nano-commands","position":38},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Basic Nano Commands","lvl3":"Nano","lvl2":"Text Editors: Vim and Nano"},"content":"Saving Changes:\n\nPress Ctrl + O to write changes.\n\nPress Enter to confirm the file name.\n\nExiting Nano:\n\nPress Ctrl + X to exit Nano.\n\nEditing Text:\n\nUse arrow keys to navigate.\n\nUse Backspace to delete characters.\n\nPress Ctrl + K to cut a line.\n\nPress Ctrl + U to paste the cut line.\n\n","type":"content","url":"/unix#basic-nano-commands","position":39},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Choosing an Editor","lvl3":"Nano","lvl2":"Text Editors: Vim and Nano"},"type":"lvl4","url":"/unix#choosing-an-editor","position":40},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Choosing an Editor","lvl3":"Nano","lvl2":"Text Editors: Vim and Nano"},"content":"The choice between Vim and Nano often depends on personal preference and familiarity. Vim’s power lies in its extensive features, while Nano excels in simplicity and ease of use. Both editors offer efficient ways to manipulate and edit text, and the choice ultimately depends on your comfort level and requirements.\n\n","type":"content","url":"/unix#choosing-an-editor","position":41},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl2":"Piping UNIX Commands"},"type":"lvl2","url":"/unix#piping-unix-commands","position":42},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl2":"Piping UNIX Commands"},"content":"Piping involves directing the output of one command as input to another command. The symbol for piping is |. This allows you to chain commands together, creating powerful and flexible workflows.\n\n","type":"content","url":"/unix#piping-unix-commands","position":43},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Example 1: Basic Pipe between Two Commands","lvl2":"Piping UNIX Commands"},"type":"lvl4","url":"/unix#example-1-basic-pipe-between-two-commands","position":44},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Example 1: Basic Pipe between Two Commands","lvl2":"Piping UNIX Commands"},"content":"ls -l | grep \"txt\"\n\nThe ls -l command lists files in long format.\n\nThe output of ls -l is piped (|) to the grep \"txt\" command.\n\ngrep \"txt\" searches for lines containing the string “txt” in the output.\n\nOpen Question\n\nIs there any unexpected behavior with this command? How could it get you to the wrong answer?\n\n","type":"content","url":"/unix#example-1-basic-pipe-between-two-commands","position":45},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Example 2: Saving Output using Piping","lvl2":"Piping UNIX Commands"},"type":"lvl4","url":"/unix#example-2-saving-output-using-piping","position":46},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Example 2: Saving Output using Piping","lvl2":"Piping UNIX Commands"},"content":"You can also pipe the output of a UNIX command into a text file to save it. Here’s an example:# List all files in the current directory and save the output to a text file\nls -l > file_list.txt\n\nAgain, the ls -l command lists files in long format.\n\nThe > symbol redirects the output of the command to a file.\n\nfile_list.txt is the name of the text file where the output will be saved.\n\nAfter executing this command, the detailed listing of files in the current directory will be saved in the file_list.txt file.\n\nExercise Two: Experimenting with Commands\n\nIn your shell/terminal (Terminal on Mac, Ubuntu on WSL), try\n\nls | wc\n\nls -l | wc\n\nls | wc -l\n\nWhat do you think each of these do?\n\n","type":"content","url":"/unix#example-2-saving-output-using-piping","position":47},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl2":"And that’s it!"},"type":"lvl2","url":"/unix#and-thats-it","position":48},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl2":"And that’s it!"},"content":"\n\n","type":"content","url":"/unix#and-thats-it","position":49},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl2":"Appendix: Useful UNIX commands for your reference"},"type":"lvl2","url":"/unix#appendix-useful-unix-commands-for-your-reference","position":50},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl2":"Appendix: Useful UNIX commands for your reference"},"content":"Here’s a list of some important UNIX commands that can serve as a quick reference:\n\npwd: Print the current working directory.\n\nls: List files and directories in the current directory.\n\ncd: Change the current working directory.\n\ncd /path/to/directory: Change to the specified directory.\n\ncd ..: Move up one level in the directory hierarchy.\n\nmkdir: Create a new directory.\n\nmkdir new_directory: Create a directory named “new_directory”.\n\ncp: Copy files or directories.\n\ncp file.txt /path/to/destination: Copy “file.txt” to the specified destination.\n\nmv: Move or rename files or directories.\n\nmv old_name new_name: Rename a file or directory.\n\nmv file.txt /path/to/destination: Move “file.txt” to the specified destination.\n\nrm: Remove files or directories.\n\nrm file.txt: Remove “file.txt”.\n\nrm -r directory: Remove a directory and its contents.\n\ncat: Display the content of a file.\n\ncat file.txt: Display the content of “file.txt”.\n\necho: Print text to the terminal.\n\necho \"Hello, World!\": Print the text “Hello, World!”.\n\nman: Display the manual or help for a command.\n\nman ls: Show the manual for the ls command.\n\nchmod: Change file permissions.\n\nchmod +x script.sh: Add execute permission to a script.\n\ngrep: Search for a pattern in files.\n\ngrep pattern file.txt: Search for “pattern” in “file.txt”.\n\nps: Display information about running processes.\n\nps aux: Show detailed information about all processes.\n\nkill: Terminate a process.\n\nkill process_id: Terminate the process with the specified ID.\n\nnano or vim: Text editors for creating and editing files.\n\nnano filename.txt: Open “filename.txt” in the Nano text editor.\n\nThese commands cover basic file and directory manipulation, text file viewing, process management, and more.","type":"content","url":"/unix#appendix-useful-unix-commands-for-your-reference","position":51},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments"},"type":"lvl1","url":"/environments","position":0},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments"},"content":"Now that we have a foundational understanding of UNIX and filesystems, let’s explore the Python programming language and its ecosystem. Python is widely used in scientific computing, and understanding its installation, package management, and the use of virtual environments is crucial.\n\n","type":"content","url":"/environments","position":1},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments","lvl2":"Python Installation and Package Management"},"type":"lvl2","url":"/environments#python-installation-and-package-management","position":2},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments","lvl2":"Python Installation and Package Management"},"content":"Python can be installed in different ways on your computer. Usually, when we use python we also use external libraries. An external library is basically a collection of useful code written by someone else that you can acess without having to rewrite it yourself (you will learn more about these over the next few weeks). Python relies on package managers to install, update, and manage external libraries. The two primary package managers are:\n\npip: The default Python package installer.\n\nExample: pip install package_name\n\nConda: A cross-language package manager that simplifies dependency management.\n\nExample: conda install package_name\n\nUnderstanding how to use these package managers is essential for incorporating external libraries into your Python projects. You might also encounter homebrew or MacPorts. These are two other popular package managers, but they are not as common in astronomy.\n\n","type":"content","url":"/environments#python-installation-and-package-management","position":3},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments","lvl3":"Using Conda as a Package Manager","lvl2":"Python Installation and Package Management"},"type":"lvl3","url":"/environments#using-conda-as-a-package-manager","position":4},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments","lvl3":"Using Conda as a Package Manager","lvl2":"Python Installation and Package Management"},"content":"When we use conda, we have the option of using different distributions:\n\nMiniconda: A minimal installer for the Conda package manager, which only includes Conda and Python.\n\nAnaconda: A distribution that includes Python, Conda, and a large array of pre installed packages.\n\nOne of the features of conda (as opposed to pip) is that we can create virtual environments. You should all now have miniconda installed, so we can start making a virtual environment!\n\n","type":"content","url":"/environments#using-conda-as-a-package-manager","position":5},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments","lvl2":"Python Virtual Environments"},"type":"lvl2","url":"/environments#python-virtual-environments","position":6},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments","lvl2":"Python Virtual Environments"},"content":"","type":"content","url":"/environments#python-virtual-environments","position":7},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments","lvl3":"What is a Virtual Environment?","lvl2":"Python Virtual Environments"},"type":"lvl3","url":"/environments#what-is-a-virtual-environment","position":8},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments","lvl3":"What is a Virtual Environment?","lvl2":"Python Virtual Environments"},"content":"A virtual environment in Python is a self-contained directory that encapsulates a specific Python interpreter along with its associated libraries and scripts. It allows you to create isolated environments for different projects, each with its own set of dependencies, without affecting the system-wide Python installation.","type":"content","url":"/environments#what-is-a-virtual-environment","position":9},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments","lvl3":"Why Use Virtual Environments?","lvl2":"Python Virtual Environments"},"type":"lvl3","url":"/environments#why-use-virtual-environments","position":10},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments","lvl3":"Why Use Virtual Environments?","lvl2":"Python Virtual Environments"},"content":"When working on multiple projects, each with its own set of dependencies, managing packages can become challenging. Virtual environments provide an isolated space for each project, allowing you to avoid conflicts between different project requirements. Code in pacakges and libraries can often change with new releases and versions, so it’s important to work in environments to keep track of your Python version and the versions of the external packages you use.\n\nNote\n\nIt is always a good idea to create a new environment when you are starting a new research project, installing a particularly complex code that has a lot of dependencies, or developing your own piece of software.\n\nExercise One: Make an Environment\n\nIn your shell/terminal, writeconda create -n astro-rps python=3.9 numpy scipy matplotlib astropy pandas jupyterlab ipython ipykernel nb_conda_kernels\n\nThis line creates as conda virtual environment called astro-rps. When you run this, you will eventually get a prompt asking for a Y/n input; type Y and hit enter.\n\nWhat this commmand does is create a new environment with the name you give it. We’ve specifically told it to use Python 3.11. We’ve also given it a list of packages that can be installed via conda; I chose these because they are universally useful in astronomy and we will need them anyway. You can specify their versions here, as we did for python, but for now, we just want the latest versions.\n\nExercise Two: Activate Your Environment\n\nOnce your environment is created, you’ll see instructions for “activating” it. Follow them, e.g.,conda activate astro-rps\n\nOnce inside the environment, you should see its name on the left hand side of your terminal prompt, in parenthesis. Lets install a few more things, but this time, using pip, the standard python package installerpip install tqdm \npip install astroquery\n\nInstalling Individual Pacakges: Conda vs. Pip\n\nWhen do we install a package using conda, and when do we use pip? This is a bit messy, but in general, I suggest checking first if a conda version of the package is available. If it is, try installing via conda first. If not, or if that fails, then fall back on using pip (Inside your environment of course!). Using pip inside an environment will still mean you are only installing to that environment, but some of conda’s ways of measuring package dependencies and compatibility don’t extend to things installed with pip. Generally, we create environments with the “big things” installed with conda (as above), then install smaller, or pip-only things, inside with pip.","type":"content","url":"/environments#why-use-virtual-environments","position":11},{"hierarchy":{"lvl1":"First Python Codes"},"type":"lvl1","url":"/first-python-codes","position":0},{"hierarchy":{"lvl1":"First Python Codes"},"content":"Last week, we focused on how to navigate the Terminal, and set up our environments from which we can run Python. This week, we’re going to actually run Python. By the end of this part of today’s lesson, you will be able to...\n\nRun Python interactively through the Terminal\n\nCreate, edit, and run .py “scripts”: saveable, reproducible Python codes\n\nUnderstand and demonstrate the basic use of the print() function\n\nWrite and run your own classic “Hello World!” Python script\n\nWrite a multi-line Python script and understand basic program layout\n\n","type":"content","url":"/first-python-codes","position":1},{"hierarchy":{"lvl1":"First Python Codes","lvl2":"A Quick Reminder"},"type":"lvl2","url":"/first-python-codes#a-quick-reminder","position":2},{"hierarchy":{"lvl1":"First Python Codes","lvl2":"A Quick Reminder"},"content":"\n\nLast week, we set up conda environments that we’ll be using for the whole Astro-RPS series. Before we move forward, you’ll want to move into your “working directory” where you’ve been working on everything up till now (reminder: you can use cd [dirname] to navigate to your working directory from within the terminal). Once you’ve done that, activate the astro-rps environment:conda activate astro-rps\n\nNow, you can activate Python in the same terminal by simply typing:\n\npython\n\nor equivalently,\n\npython3.8\n\nIf things work properly, you should see a message that includes a few details about the Python version you are running, your operating system, etc. If you do, you should see a blinking cursor ready for you to type code in, often preceded by a >>>. From here, we should already be able to do some basic calculations.\n\nExercise One: Basic Mathematical Operations\n\nIn your shell/terminal where you have started up Python, try adding two numbers as below:10 + 2\n\n(hit enter when you’re done typing). This should return a single number. Then, tryprint(10+2)\n\nagain, hit enter. Is the output the same, or different? What happens when you swap out the + with “-”, then “/”, then “*”. What do each of these return?\n\nLastly, try:print(10 / 0)\n\nWhat happens?\n\nNow, in the same terminal, typeexit()\n\nand hit enter. Once you’ve done so, congrats! You’ve started, written, completed, and quit your first Python session.\n\nFrom here on, we actually will not recommend you use just “python” and instead recommend:   ipython\n\nThe differences are mostly unimportant, but it has some conveniences (like colored text for different keywords) that make it nicer to use.\n\nRunning Python Interactively in the Terminal vs. “Scripting”\n\nWhen we run Python interactively like we did above, then quit, none of the operations and outputs are saved. While you can sometimes use the up arrowkey to see recent commands and perhaps re-run them that way manually, this this obviously isn’t the way most codes are written: we normally care a lot about saving our work so that we can expand upon it later and re-run. So, in short, don’t do work in interactive Python sessions that you want to preserve later.\n\nWhat do we instead? We create scripts. This is just a fancy way of saying “codes that we save in files”. In Python, these have the file extension .py, i.e., you might call your script “code.py” (or hopefully something more descriptive).\n\nTo create a script, first exit Python. This should you leave in a normal bash shell, from which you can type\n\ntouch first_script.py\n\nThe command “touch” simply creates a basic text file with the name provided afterwards (here, first_script.py). We are now free to edit this file through whatever means we want: for now, open it up in whatever text editor you prefer (e.g., TextEdit, Notepad, Text Editor for Mac, Windows, and Linux respectively).\n\nNow, try adding print(\"Hello World!\")\n\ninto that file and save it. Then, open up a bash terminal (don’t type python) and typepython first_script.py\n\nfrom within the same directory where you saved the file. If you’re in the right place, your bash shell should print out the words Hello World. If you run into an error, check first that you’re in the right directory (and if not, use cd to get there).\n\n","type":"content","url":"/first-python-codes#a-quick-reminder","position":3},{"hierarchy":{"lvl1":"First Python Codes","lvl2":"Comments"},"type":"lvl2","url":"/first-python-codes#comments","position":4},{"hierarchy":{"lvl1":"First Python Codes","lvl2":"Comments"},"content":"\n\nWhat if we want to put something into the code that we don’t want to run? In that case, we can comment lines using the #. For our script above, we could add a description of what the code is doing as follows:\n\n # This is a program to print the words Hello World.\n print(\"Hello World!\") # this is the line that does the printing.\n\nAs can be seen, anything after the hashtag is completely ignored by Python.  This is true whether you’ve put the commented phrase on its own line or at the end of another line.\n\nThere’s not much more to comments than this! Broadly speaking, commenting is vital piece of making sure codes are understandable. We encourage you to include comments throughout your codes that indicate what important lines are doing. This will help avoid the situation where you log on a week later and totally lose the train of thought that you had the previous week (speaking from experience, we promise this really will happen).\n\n","type":"content","url":"/first-python-codes#comments","position":5},{"hierarchy":{"lvl1":"First Python Codes","lvl2":"Writing Multi-line Programs"},"type":"lvl2","url":"/first-python-codes#writing-multi-line-programs","position":6},{"hierarchy":{"lvl1":"First Python Codes","lvl2":"Writing Multi-line Programs"},"content":"\n\nWith the basics down, we can start to complexify. In Python, distinct commands are separated onto different lines. In most situations, Python is linear: lines are executed from the top to the bottom. To see this for a case when you want to print two different things, you can write the code:# This code prints a phrase and a number.\nprint(\"Hello World!\")\nprint(5+5)\n\nEach print statement has an implicit (but hidden) command at the end that tells it to move to the next line after printing, so you should find that this prints out each result on its own line. If you don’t want that, one choice of syntax to avoid that is:\n\nprint(\"Hello World!\", 5+5)\n\nwhere all we’ve done is separate the things we want by commas. As we’ll later discuss, print() is what we call a function that can take any number of arguments (things inside the parantheses).\n\nDoes the spacing and layout of the script file matter?\n\nYes and no. In general, “vertical” spacing in Python does not matter - you can feel free to hit enter as many times between the lines in your .py file. The number of spaces within the middle of a line also doesn’t matter, so print(5 + 5) yields the same result as print(5        +      5). However, horizontal aligment does matter. Lines should generally all start at the same left-justification, unless you are working with if statements, loops, or creating your own functions (more on each of those later). Let’s try to write a very simple code to demonstrate this.\n\nExercise Two: Testing Python Spacing Rules\n\nIn your first_codes.py file, add a tab or some spaces before the start of the second line:print(\"Hello World!\")\n    print(5+5)\n\nWhen you try to run this script, you should find that “Hello World” does not print. Instead, you will get an IndentationError - telling you that Python expected the second line to be left-aligned with the first line. You might wonder: why does the first line not work, even if the error is on the second line?\n\nThe short answer is that Python does a quick check before running your code to see if there any obvious bugs. This procedure is not quite as robust as in some other programming languages, and it won’t catch things like DivideByZero errors, infinite loops, etc. However, it will raise an immediate error if it seems things like unusual spacing or undefined variables (more on the latter in the next notebook).  Thus, for the example above, the error is raised before the first line of code is actually run, breaking the program flow.\n\n","type":"content","url":"/first-python-codes#writing-multi-line-programs","position":7},{"hierarchy":{"lvl1":"First Python Codes","lvl2":"What if we want to store information between lines?"},"type":"lvl2","url":"/first-python-codes#what-if-we-want-to-store-information-between-lines","position":8},{"hierarchy":{"lvl1":"First Python Codes","lvl2":"What if we want to store information between lines?"},"content":"\n\nThus far, we’ve only done a very simple set of computations and immediately printed the result. What if we instead wanted to store the result of that calculation for later? In that case, we will want to define a variable. It’s best to see this by example:\n\nresult = 5 + 5 \nprint(result)\n\nHere, we have stored the result of the 5+5 . We could have named “result” anything we wanted - you’re free to choose the name (within certain rules - e.g., t can’t start with a number). In this context, the = sign acts as a so-called “assignment operator”: it takes whatever is on the righthand side and stores it in whatever we have called the variable on the lefthand side. It has nothing to do with equalities or truth/falsity.\n\nWe now have everything we need to write our first useful Python program.","type":"content","url":"/first-python-codes#what-if-we-want-to-store-information-between-lines","position":9},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes"},"type":"lvl1","url":"/variables-datatypes-2025","position":0},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes"},"content":"In the prior notebook, we introduced how to write more sophisticated multi-line codes using scripts. Here, we’re going to momentarily put scripting aside and focus on introducing some basic vocabulary that we will build on throughout the series. By the end of the day, you should be able to...\n\nDefine the most important variable types in Pythons (int, float, string, list)\n\nUse F-strings to refer to variables in printed strings\n\nUse basic indexing to access elements of a list\n\nWrite codes that take in inputs from the command line\n\nUnderstand the basic distinction between functions, objects, and variables\n\n","type":"content","url":"/variables-datatypes-2025","position":1},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl2":"Variables in Python"},"type":"lvl2","url":"/variables-datatypes-2025#variables-in-python","position":2},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl2":"Variables in Python"},"content":"\n\nIn the previous notebook, we restricted our consideration of variables to simple numerical variables that we could add, subtract, multiply etc. easily in Python. However, variables are a lot more flexible than that in Python. To illustrate this point, here are four different valid variable definitions:\n\n# define six different Python variables\nx = -6\nwidth = 7.0\nanimal_name = 'cat'\ndogs_are_friends = True \nlist_of_classes = ['french', 'galaxies', 'philosophy']\ndictionary1 = {'Name': 'Steve', 'Address': '219 Prospect Street', 'Office Number': 501}\n\nReminder: the ‘=’ sign in each line of the above is NOT a mathematical statement. A single equals sign is the assignment operator: it takes whatever is on the righthand side and stores it in the lefthand side. As before, we are free to print any of these, e.g.,print(list_of_classes)\n\nwhich largely just prints whatever was on the righthand side of our variable declaration.\n\nAs is clear from the above examples, there’s clearly a diversity in what can be stored in a Python variable. We call the different types of things that variables can be data types. All the data types have a unique name and a set of properties. To see their names, we can try:\n\nprint(type(width))\n\nExercise One: Deducing variable types in Python\n\nUsing a terminal session in Python or a script, find the data types for the remaining variables in the earlier cell.\n\nNow that we know how to check the type of a given variable, let’s dig into the properties of each type.\n\n","type":"content","url":"/variables-datatypes-2025#variables-in-python","position":3},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl3":"Integers","lvl2":"Variables in Python"},"type":"lvl3","url":"/variables-datatypes-2025#integers","position":4},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl3":"Integers","lvl2":"Variables in Python"},"content":"\n\nIntegers (int) for short are your run-of-the-mill counting numbers (.., -2, -1, 0, 1, 2.. etc). They obey all the basic arithmetic you expect:\n\na =  6\nb = -4 \nprint(a+b, a-b, a * b)\n\nIn each of these cases, adding/subtracting/multiplying two integers results in another integer. This is hopefully intuitive. But what about dividing two integers?\n\nc = 5\nd = 2\ne = c / d\n\nprint(e) ## print the result of the calculation above\n\nIf we now check the type of the result,\n\nprint(type(e))\n\nWe can see that it’s something else -- a float.\n\n","type":"content","url":"/variables-datatypes-2025#integers","position":5},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl3":"Floats","lvl2":"Variables in Python"},"type":"lvl3","url":"/variables-datatypes-2025#floats","position":6},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl3":"Floats","lvl2":"Variables in Python"},"content":"\n\nFloats, short for “floating point numbers,” are numbers with decimal places. As can be seen from the example above, Python automatically recognizes that it needs to use a float variable type to store the division of the variable c by the variable d. This is NOT the case in many other programming languages! In Java or C, for example, e would be an integer result equal to 2. Python is free to do this because it dynamically allocates memory to variable types, as opposed to pre-specifiying how much memory a variable needs.\n\nIf we want to specify that a number is a float, there are at least three equivalent ways of doing that:\n\nf1 = float(24)\nf2 = 24.\nf3 = 24.0\n\nprint(type(f1), type(f2), type(f3))\n\nIn the first line here, float() is a function that takes whatever is in the parantheses (the so-called argument) and converts it to a float.\n\nExercise Two: The Stefan-Boltzmann Law\n\nCreate a new code file called “SB.py”. Within SB.py, write the necessary code to calculate the Luminosity (L) of a star according to the Stefan-Boltzmann law,L = 4\\pi R^2 \\sigma T^4\n\nIn doing so, define a unique variable for each of L, pi, sigma, R, and T (where the latter are radius and temperature); don’t just put the computation in a print statement. Using pi = 3.14 and sigma = 5.67 * 10^{-8} \\rm \\ W/m^{2}/K^{4},\nwhat is the luminosity of a star with R = 7 * 10^8 meters and T = 5776 K? You can assume the units work out (and therefore you can ignore them in Python). Hint: use the ** to use powers in Python, e.g., 2 ** 3 will give you 8.\n\nPrint L and compare your value to the Solar luminosity, 3.8 * 10^{26} Watts. Is your value greater, less than, or equal to the Solar luminosity?\n\n","type":"content","url":"/variables-datatypes-2025#floats","position":7},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl3":"Strings","lvl2":"Variables in Python"},"type":"lvl3","url":"/variables-datatypes-2025#strings","position":8},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl3":"Strings","lvl2":"Variables in Python"},"content":"\n\nStrings are essentially just letters enclosed by pairs of quotes ’ '. Almost any common character can be included in a string, including things like spaces, and strings can be any length (including length 0). Some examples:\n\nanimal_name = 'cat'\nblank_string = ''\nnet_id = 'zzz56'\nprint(animal_name, blank_string, net_id)\n\nNote that both single and double quotes will both work - just be consistent.\n\nIf you want to check how many characters are in a string, you can use the len() function:print(len(animal_name))\n\nReferencing Variables within Strings\n\nOften, you will find yourself wanting to write programs where you compute a result and then describe it in the context of a sentence/phrase. In Python, we do this using what are called “F-strings”. They work like this:age = 22\nread_age = 19\n\nprint(f\"I am {age} years old\")\n\nYou can do this with any number of variables in your string:age = 22\nread_age = 19\nprint(f\"I am {age} years old and I learned to read at {read_age}\")\n\nNote that this is functionally equivalent to doingage = 22\nread_age = 19\nprint(\"I am\", age, \"years old and I learned to read at\", read_age)\n\npotentially up to some spacing differences.\n\nAnother property of strings is that they can be concatenated (added together) with the “+” operator. For example,string1 = 'hot'\nstring2 = 'dog'\nprint(string1 + string2)\n\nExercise Three: Exploring String Operations\n\nIn the above, we showed that strings can be concatenated with “+”. But what does “-” or “*” do? What happens if you do a string * a number?\n\nLastly, it is occasionally useful to note that you can force quantities to be strings by using the str() function. For example, acc = str(9.8)\nprint(type(acc))\n\n","type":"content","url":"/variables-datatypes-2025#strings","position":9},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl3":"Lists","lvl2":"Variables in Python"},"type":"lvl3","url":"/variables-datatypes-2025#lists","position":10},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl3":"Lists","lvl2":"Variables in Python"},"content":"\n\nLists are exactly what they sound like: they are lists of “stuff” in Python, enclosed by hard brackets [ ]; the items in the list are called elements. You can put anything within a list, including any other data type (and even lists..)\n\n# a list of elements with all the same data types:\nlist_of_animals = ['cat', 'dog', 'frog']\nprint(list_of_animals)\n\n# a list of elemetns with varied data types:\nrandom_stuff = ['8', True, 'frog', (8,7)]\nprint(random_stuff)\n\n# an empty list\nempty_list = []\nprint(empty_list)\n\nJust like we did for strings, we can find the length of a list as follows:list1 = ['a','b','c','d']\nlength = len(list1)\nprint(length)\n\nIf we have an existing list and want to add an element to the end, we can use the function .append():list1 = ['a','b','c','d']\nprint(list1, len(list1))\nlist1.append('e')\nprint(list1, len(list1)) # print again to see the effect of the change\n\nwhich might come in especially handy if you want to build up an empty list, e.g.,list_of_numbers = []\nlist_of_names.append('999-301-9191')\n\nWe can also do the same with remove():list_of_animals = ['cat','cat', 'dog', 'frog','cat']\nprint(list_of_animals)\nlist_of_animals.remove('cat')\nprint(list_of_animals)\n\n","type":"content","url":"/variables-datatypes-2025#lists","position":11},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl3":"List indexing","lvl2":"Variables in Python"},"type":"lvl3","url":"/variables-datatypes-2025#list-indexing","position":12},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl3":"List indexing","lvl2":"Variables in Python"},"content":"\n\nAn important property of lists is that they are (implictly) indexed: each element has an associated index that specifies its position. Importantly, these count up starting from 0 (not 1!!) and go up to the length of your list minus one.  For example,letters = ['a','b','c','d']\nprint(letters[0]) # return the first item in the list\nprint(letters[1]) # return the second item in the list\n\nIf you try to use an an index that is >= the length of the list, you will run into an error since that index doesn’t exist:letters = ['a','b','c','d']\nprint(letters[4]) # attempt to return the 5th element of a 4-element list; this will fail\n\nAnother useful index is -1, which will return the last element of the list:letters = ['a','b','c','d']\nprint(letters[-1]) # this will print 'd'\n\nIf we only want to print a subset of the list, you can use so-called list “slicing” with the colon (:). You can specify both the starting and ending index, as such:\n\nletters = ['a','b','c','d']\nprint(letters[1:3]) # this will print\n\nHere, only two elements are return because the : will not select the element with index equal to the number that comes after the colon.\n\nExercise Four: Practice accessing Specific Elements in a List\n\nDefine a list containing the first 7 powers of 2 (i.e., 2, 4, 8, etc).\n\nWhat is the index of the number 8 in your list?\n\nUsing list slicing, select the elements [8,16,32] and store them in a variable called middle_numbers\n\nWe can also use functions to compute summary statistics for lists comprised only of numbers, e.g.,grades = [71, 85, 81, 92, 97, 100, 67, 45]\nworst_grade = min(grades)\nbest_grade = max(grades)\n\nprint(f\"The worst grade on the test was {worst_grade} and the best grade was {best_grade}.\")\n\nExercise Five: Calculating Averages\n\nConsider the list of grades above. Using the sum() and len() functions, find the average of the reported grades.\n\n","type":"content","url":"/variables-datatypes-2025#list-indexing","position":13},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl2":"Booleans"},"type":"lvl2","url":"/variables-datatypes-2025#booleans","position":14},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl2":"Booleans"},"content":"\n\nBooleans are essentially binary truth values: True or False.\n\nis_physics_fun = False\ntoday_is_Monday = True\n\nThey can naturally arise when using (in)equality operators:\n\nprint(6 > 7)\nprint('cat' == 'cat') # double equal sign checks for equality; single equal sign is for assignment\nprint('cat' != 'cat')  # != is how we say \"not equal to\" in Python\n\nAs with any other type of variable, you could store the output of some operation as follows:\n\nresult = (7 > 6) # evaluate the inequality, and store a boolean in the variable called result\nprint(result)\n\nBooleans are very useful for controlling program flow. We’ll discuss this at length next week.\n\n","type":"content","url":"/variables-datatypes-2025#booleans","position":15},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl2":"Dictionaries"},"type":"lvl2","url":"/variables-datatypes-2025#dictionaries","position":16},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl2":"Dictionaries"},"content":"\n\nA more complicated -- but very useful -- data type in Python is the dictionary. It provides a structured way to store data that can be accessed with a “key” (roughly, a column name). For example,dictionary1 = {'Name': 'Steve', 'Address': '219 Prospect Street', 'Office Number': 501}\nprint(dictionary1['Name'])\n\nIn the event you need to access the list of fields, you can print dictionary1.keys().\n\n","type":"content","url":"/variables-datatypes-2025#dictionaries","position":17},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl2":"Aside: Taking Command-Line inputs during Python scripts"},"type":"lvl2","url":"/variables-datatypes-2025#aside-taking-command-line-inputs-during-python-scripts","position":18},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl2":"Aside: Taking Command-Line inputs during Python scripts"},"content":"\n\nA useful function when writing scripts is input(). If you include this in your code as follows,var_to_set = input()\nprint(f\"Your input was {var_to_set}\")\n\nyour input will be recored in the variable var_to_set.\n\nExercise Six: Practice accessing Specific Elements in a List\n\nReturn to your program for creating averages from earier. Now, rather than using the list provided called grades, write the program to use input() to populate an empty list with grades (for now, you can just use five lines of input() - we’ll show you how to make ths more automated next week). Then, run the average code over your user-provided list, and print the result in a sentence using an F-string.\n\nAs test case, try inputting [100,100,80,60,60] and verify that your code produces 80.\n\n","type":"content","url":"/variables-datatypes-2025#aside-taking-command-line-inputs-during-python-scripts","position":19},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl2":"The Big Picture: Objects and Functions in Python"},"type":"lvl2","url":"/variables-datatypes-2025#the-big-picture-objects-and-functions-in-python","position":20},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl2":"The Big Picture: Objects and Functions in Python"},"content":"\n\nPython is what we call an object-oriented program language. The term objects here refer to bundles of data (attributes) and functions (which often act on that data). The structure of objects (e.g., what functions they contain) is defined by a class; this is why you see the word <class when you run type() on a variable. All Python data types are classes, and by extension, all variables are objects.. For example, let’s take the case of a list:mylist = [5,4]\nmylist.append(5)\n\nHere, mylist is an object of type list, with a value of [5,4]. All objects of type list have a function .append() associated with them. This isn’t true for objects of type int,str, etc -- they have their own functions associated with them since they are each types defined by different classes.\n\nA fun example of a class function associated with int() is as_integer_ratio():var = 3\nprint(var.as_integer_ratio())\n\nAs a general comment, functions are almost always accompanied by a double parantheses(). Anything within those parantheses is called an argument. In the case above, the object itself (var) is an implict argument of the function (as_integer_ratio()).\n\nWe’ll take much more about functions and objects throughout this series, so don’t worry if this is a bit jargon-y and opaque at this point. For now, we will move on to introduce another important datatype called the array.","type":"content","url":"/variables-datatypes-2025#the-big-picture-objects-and-functions-in-python","position":21},{"hierarchy":{"lvl1":"Numpy and Arrays"},"type":"lvl1","url":"/numpyarrays","position":0},{"hierarchy":{"lvl1":"Numpy and Arrays"},"content":"One major data type that we have not yet introduced is the array -- a close sibling of the list. One reason we’ve isolated it here is because it is not included in default Python -- instead, it’s included in a package that we can import. The array offers many important advantages over the list when it comes to vectorized operations (which we’ll define below).\n\nBy the end of the day, you’ll be able to\n\nImport the numpy package\n\nConstruct and manipulate numpy arrays\n\nCompare and contrast numpy arrays and lists\n\nApply numpy functions for simple but important calculations\n\nIn tandem with this notebook, I recommend creating a new script that you can use as a playground - it’s best not to use python interactiely in the shell as we move to more sophisticated programs.\n\n","type":"content","url":"/numpyarrays","position":1},{"hierarchy":{"lvl1":"Numpy and Arrays","lvl2":"Importing Numpy (and other Packages)"},"type":"lvl2","url":"/numpyarrays#importing-numpy-and-other-packages","position":2},{"hierarchy":{"lvl1":"Numpy and Arrays","lvl2":"Importing Numpy (and other Packages)"},"content":"\n\nAs part of your conda environment for this series, you downloaded a number of packages that are ubiquitously used throughout Python programming in any context. One of those packages is called numpy, which is short for numerical Python. You can import this package via the line\n\nimport numpy as np\n\nwhere the “as np” part is optional and just defines an alias (short name) that can save you a bit of typing later on.  After you’ve done this, you now have access to a large number of useful data structures and efficient, practical functions available as part of the package!\n\nImport statements only needed to be called once at the start of the program (whether that be a script or in a python shell). Generally, we like to include them in a block at the top of the code, e.g.,import numpy as np\nimport scipy\nimport astropy\n\nWe won’t go into any more detail about packages for the day, but we will dig into the numpy package specifically since it complements the rest of the material we were discussing about data types.\n\n","type":"content","url":"/numpyarrays#importing-numpy-and-other-packages","position":3},{"hierarchy":{"lvl1":"Numpy and Arrays","lvl3":"Motivating numpy: The Problem with Lists and the need for Arrays","lvl2":"Importing Numpy (and other Packages)"},"type":"lvl3","url":"/numpyarrays#motivating-numpy-the-problem-with-lists-and-the-need-for-arrays","position":4},{"hierarchy":{"lvl1":"Numpy and Arrays","lvl3":"Motivating numpy: The Problem with Lists and the need for Arrays","lvl2":"Importing Numpy (and other Packages)"},"content":"\n\nThe main purpose of numpy is to allow for efficient data handling and computation, including for multidimensional collections of objects.  Numpy achieves this by improving on the list data type through a new data type called an “array”. To understand why the array is different (and better), let’s define one of each:\n\n# define a list using default Python\nlist1 = [1,3,5]\n\n# np.array() is a function that takes a list as an argument and converts it into an array\narray1 = np.array([1,3,5]) \n\nprint(list1)\nprint(array1)\n\nLet’s now say we want to add 10 to each element in list1 and array1. You might think of trying:print(list1 + 10)\n\nbut evidently that returns an error. Default Python doesn’t think you can simply add a single number to a list, because they are incompatible datatypes. Contrast that with numpy:print(array1 + 10)\n\nwhich has the expected effect of adding 10 to each element.\n\nExercise One: An Unusual Property of Lists\n\nFirst, define a list of numbers called nums. Then, try to multiply this list by 5. Does it return an error? If not, what does it return?\n\nNow, make a new variable num_arr by converting nums from a list into a numpy array. Then, try multiplying by 5 again. What happens this time?\n\nA related behavior of list is seen if you try adding them:print([1,3,5] + [2,4,6])\n\nversues if you try with arrays,a = np.array([1,3,5])\nb = np.array([2,4,6])\nprint(a+b)\n\nIn short, numpy usually does what you expect to see from vectors: we call these element-wise operations.\n\nThe numpy advantage, in short, is being able to do vector operations. This works much faster than looping through eac (which is a generally slow thing to do in Python).\n\nWhile we’re here, one disadvantage of numpy arrays is that unlike lists, all elements in a numpy array must be the same data type. Thus, you can’t have an array [“cat”, 6], for example, while you could for a list.\n\n","type":"content","url":"/numpyarrays#motivating-numpy-the-problem-with-lists-and-the-need-for-arrays","position":5},{"hierarchy":{"lvl1":"Numpy and Arrays","lvl2":"More reasons to use numpy: A myriad of useful functions"},"type":"lvl2","url":"/numpyarrays#more-reasons-to-use-numpy-a-myriad-of-useful-functions","position":6},{"hierarchy":{"lvl1":"Numpy and Arrays","lvl2":"More reasons to use numpy: A myriad of useful functions"},"content":"\n\nEven if you don’t care about arrays, numpy offers many useful convenience functions that are not offered in default Python.\n\nFor example, you might want to try to compute the cosine of an angle:print(np.cos(10)) ## cosine function\n\nor generate N evenly-spaced numbers between two endpoints of an interval,low = 0\nhigh = 100\nN = 101\narr = np.linspace(low,high,N) ## generate 51 evenly spaced numbers between 0 and 5\nprint(arr)\n\nor get the mean and median of a list/array quickly:vals = [1,3,5,7,9]\nprint(np.mean(vals), np.median(vals))\n\nNote that in the above example, vals is actually a list - not an array. That’s fine - numpy will do the conversion for you under the hood.\n\nThis might not seem that impressive yet, but it becomes really useful when dealing with multi-dimensional data. If we wanted, for example, we could definite a numpy array of zeros of shaping 50x50 as follows:\n\nblank_image = np.zeros((50,50))\nprint(blank_image)\n\nWe could then add or mulyiply a scalar value easily, or take the mean, or all at once!)print(np.mean(5*blank_image + 2))\n\nand it just acts like a giant vector. You can see where this might be going when it comes to manipulating astronomical images!","type":"content","url":"/numpyarrays#more-reasons-to-use-numpy-a-myriad-of-useful-functions","position":7},{"hierarchy":{"lvl1":"Introduction to Imports"},"type":"lvl1","url":"/packages","position":0},{"hierarchy":{"lvl1":"Introduction to Imports"},"content":"","type":"content","url":"/packages","position":1},{"hierarchy":{"lvl1":"Introduction to Imports","lvl2":"Part 1: import numpy as np"},"type":"lvl2","url":"/packages#part-1-import-numpy-as-np","position":2},{"hierarchy":{"lvl1":"Introduction to Imports","lvl2":"Part 1: import numpy as np"},"content":"\n\nchances are you have seen us do the following at the top of our lectures/scripts/notebooks\n\nimport numpy as np\n\nso what exactly are we doing here?\n\nThe import keyword is used to tell Python that you want to bring in functionality from an external module.\n\nThis is the name of the module you want to import (in this case numpy). A module is a Python file containing Python code and definitions. It can include variables, functions, and classes.\n\nFinally you can use the as keyword to give a module or an imported element a different name (an alias). This can be useful to avoid naming conflicts or to make the code more readable.\n\nfrom now I can call the numpy package (and all its functions) using np\n\nnp.linspace(1,15,15) # for example\n\nYou can also write something like:\n\nfrom module_name import function_name, class_name\n\nwhere the function_name or class_name is specfic to the module you are trying to import!\n\nyou can also import everything using the * wild card sybmol\n\nfrom module_name import *\n\nor use some combination of the syntax above\n\nfrom module_name import element_name as alias\n\n","type":"content","url":"/packages#part-1-import-numpy-as-np","position":3},{"hierarchy":{"lvl1":"Introduction to Imports","lvl2":"Part 2: where is the code?"},"type":"lvl2","url":"/packages#part-2-where-is-the-code","position":4},{"hierarchy":{"lvl1":"Introduction to Imports","lvl2":"Part 2: where is the code?"},"content":"\n\nIf you are using “basic” packages like numpy or math, chances are you installed them when you installed python (via anaconda or something similar).\n\nThose packages live in with your base install of python and can be called anywhere within your python environment.\n\nIf you want to use your own python modules, you need to make sure the script you are working with knows where they are.\n\nThe easiest way to do this is to have your scripts in the same directory. That way you can simply import any of them using the same commands that we just reviewed.\n\nOtherwise, you might need to do something like:\n\nimport sys \nsys.path.insert(0, '../src/')\nimport my_fav_module as yessir\n\nthis sys import basically allows your current directory to know about the contents of the src folder and import them as if they were in “local”\n\nlater on, we will briefly mention how to create packages out of your own code, in the same way that people share numpy","type":"content","url":"/packages#part-2-where-is-the-code","position":5},{"hierarchy":{"lvl1":"Logic Flow and Error Parsing"},"type":"lvl1","url":"/logic","position":0},{"hierarchy":{"lvl1":"Logic Flow and Error Parsing"},"content":"","type":"content","url":"/logic","position":1},{"hierarchy":{"lvl1":"Logic Flow and Error Parsing","lvl2":"Part 1: “if/else”"},"type":"lvl2","url":"/logic#part-1-if-else","position":2},{"hierarchy":{"lvl1":"Logic Flow and Error Parsing","lvl2":"Part 1: “if/else”"},"content":"Lets talk about logic flow and start with the simplist example\n\n# Get input from the user\nnumber = int(input(\"Enter a number: \"))\n\n# Check if the number is even or odd\nif number % 2 == 0:\n    print(f\"{number} is an even number.\")\nelse:\n    print(f\"{number} is an odd number.\")\n\n\nthis is the simple syntax of the if and else statements we can to make to decide if a number is odd or even. Notice the indentation for each statment!\n\n# Get input from the user\nnumber = int(input(\"Enter a number: \"))\n\n# Check if the number is even, odd, or zero\nif number == 0:\n    print(\"You entered zero.\")\nelif number % 2 == 0:\n    print(f\"{number} is an even number.\")\nelse:\n    print(f\"{number} is an odd number.\")\n\n\nyou can add to this scheme using the elif call which works as another possible “bucket” for your number to land in.\n\nYou can have as many elif statements as you want but you only get one else statement.\n\n","type":"content","url":"/logic#part-1-if-else","position":3},{"hierarchy":{"lvl1":"Logic Flow and Error Parsing","lvl2":"Part 2: “Try/Except”"},"type":"lvl2","url":"/logic#part-2-try-except","position":4},{"hierarchy":{"lvl1":"Logic Flow and Error Parsing","lvl2":"Part 2: “Try/Except”"},"content":"Okay but you might be wondering: what if the user doesn’t input a number? what if the user accidently types in a letter or symbol instead?\n\n# Get input from the user, handling non-numeric input\ntry:\n    number = int(input(\"Enter a number: \"))\n    \n    # Check if the number is even, odd, or zero\n    if number == 0:\n        print(\"You entered zero.\")\n    elif number % 2 == 0:\n        print(f\"{number} is an even number.\")\n    else:\n        print(f\"{number} is an odd number.\")\n\nexcept ValueError:\n    print(\"Error: Please enter a valid numeric input.\")\n\n\nImportantly, this try and except statement is specific to the ValueError error message and would not work for other common error messages. Again, notice the indentation scheme!\n\nThis is an incredibly useful way of writing code since it lets your user know exactly where they have made some mistake!\n\nHere is another example in which you expect different error messages:\n\ntry:\n    # Attempt to open a file for reading\n    file_path = input(\"Enter the path to a file: \")\n    with open(file_path, 'r') as file:\n        # Read and print the contents of the file\n        content = file.read()\n        print(\"File content:\")\n        print(content)\n\nexcept FileNotFoundError:\n    print(f\"Error: The file '{file_path}' was not found.\")\n\nexcept PermissionError:\n    print(f\"Error: You don't have permission to read the file '{file_path}'.\")\n\nexcept Exception as e:\n    print(f\"An unexpected error occurred: {e}\")\n\n","type":"content","url":"/logic#part-2-try-except","position":5},{"hierarchy":{"lvl1":"Logic Flow and Error Parsing","lvl2":"Part 3: Error Messages!"},"type":"lvl2","url":"/logic#part-3-error-messages","position":6},{"hierarchy":{"lvl1":"Logic Flow and Error Parsing","lvl2":"Part 3: Error Messages!"},"content":"\n\nThis brings us nicely to our next topic: error messages.\n\nYes they can be intimidating but if you look past your intial feeling of (embarresment/anxiety/guilt/rage) you can find some pretty useful stuff hidden in the red writing!\n\nIn the loop lecture we tried to do the following:\n\nlist_Mon = [5, 12, 3, 5, 67, 1, 2, 34, 2, 89]\n\nlist_Tues = [15, 45, 21, 2, 8, 9, 54, 99, 17, 51]\n\nlist_Wed = [32, 65, 11, 9, 5, 75, 21, 14, 39, 71]\n\nlist_Mon = [5, 12, 3, 5, 67, 1, 2, 34, 2, 89]\n\nlist_Tues = [15, 45, 21, 2, 8, 9, 54, 99, 17, 51]\n\nlist_Wed = [32, 65, 11, 9, 5, 75, 21, 14, 39, 71]\n\nmin_age = 2023 - 2001\nlist_Mon > min_age\n\nSo here the error message is a TypeError and it clearly states that this operation is not supported because you are trying to compare a list to an int\n\nconviently, it also tells you the line that threw the TypeError (in this case line 8)\n\nmore often that not, you will be working with other people’s code (via packages or public tools) and often the error you get might be local! for example\n\nimport cosmolopy\n\ncosmolopy.perturbation.fgrowth(5,\"bet\") \n\nSee now this error message is the same as before, but it shows that the error doesn’t oginate in this local file, instead it was thrown in line 183 of the cosmolopy.perturbation code\n\nlocally, the error can be traced to line 3, but it orginated elsewhere. These error messages are big reason why Python is so user friendly. Make sure to take a second to understand them!\n\nhere are some common ones!\n\nSyntaxError:\nDescription: This error occurs when the Python interpreter encounters a syntax that is not valid in the language.\nExample: SyntaxError: invalid syntax\n\nIndentationError:\nDescription: Python relies on indentation to define blocks of code. This error occurs when there’s an issue with the indentation level.\nExample: IndentationError: expected an indented block\n\nNameError:\nDescription: This error occurs when a variable or name is used before it’s defined.\nExample: NameError: name ‘variable_name’ is not defined\n\nTypeError:\nDescription: This error occurs when an operation is performed on an object of an inappropriate type.\nExample: TypeError: unsupported operand type(s) for +: ‘int’ and ‘str’\n\nIndexError:\nDescription: This error occurs when trying to access an index that is outside the bounds of a sequence (e.g., list, tuple).\nExample: IndexError: list index out of range\n\nFileNotFoundError:\nDescription: This error occurs when trying to open or manipulate a file that doesn’t exist.\nExample: FileNotFoundError: [Errno 2] No such file or directory: ‘filename.txt’\n\nValueError:\nDescription: This error occurs when a function receives an argument of the correct type but an invalid value.\nExample: ValueError: invalid literal for int() with base 10: ‘abc’\n\nKeyError:\nDescription: This error occurs when trying to access a dictionary key that doesn’t exist.\nExample: KeyError: ‘key_name’\n\nZeroDivisionError:\nDescription: This error occurs when attempting to divide by zero.\nExample: ZeroDivisionError: division by zero\n\nModuleNotFoundError:\nDescription: This error occurs when trying to import a module that cannot be found.\nExample: ModuleNotFoundError: No module named ‘module_name’","type":"content","url":"/logic#part-3-error-messages","position":7},{"hierarchy":{"lvl1":"Looping in Python"},"type":"lvl1","url":"/loop","position":0},{"hierarchy":{"lvl1":"Looping in Python"},"content":"","type":"content","url":"/loop","position":1},{"hierarchy":{"lvl1":"Looping in Python","lvl2":"Part 1: “for-loops” and “while-loops”"},"type":"lvl2","url":"/loop#part-1-for-loops-and-while-loops","position":2},{"hierarchy":{"lvl1":"Looping in Python","lvl2":"Part 1: “for-loops” and “while-loops”"},"content":"This week we will be discussing basic iterable objects (lists, arrays, tuples ...) and how you can use them to repeat operations.\n\nFor example lets say you want to print something out several times. Last week you learned some numpy basics so lets start with that...\n\nimport numpy as np #importing numpy\n\nprint(np.arange(5)) # this is an array with 5 elements\n\n# start the for loop\nfor i in np.arange(5): # pay attention to the syntax (\":\") here! \n    print(i)\n\nThis is an example of a “for-loop” which is the most basic looping fucntionality in Python.\n\nIt is intiialized by typing for in front of the the variable i which is a an element in the iterable np.arange(5).\n\nIt works by iterating over each element in the numpy array. Importantly, the variable i can be anything as long as you are consistent.\n\nIt is effectively a dummy variable that represents each element in the iterable.\n\nfor wowza in np.arange(5): #now instead of \"i\" I used the \"wowza\" variable\n    print(wowza)\n\nYou could do somethign similar with a “while-loop” which unlike the “for-loop” iterates as long as some condition is met. For example:\n\n# Initialize a counter\ncounter = 0\n\n# Define the condition for the while loop\nwhile counter < 5:\n    print(counter)\n    counter += 1  # Increment the counter\n\nExercise: A useful while loop\n\nWhile loops are usually not that useful, because normally we have an iterable where we know the length. But what if we have a program and don’t know how many times the loop will need to run?\n\nYour program from last week takes inputs (like star temperature and radius) and outputs the luminosity. We could make this program run indefinitely (so that it keeps asking for more inputs) and provides more answers until the code is quit. We could also use this technique to make sure the users have entered the right type of value (via try and except).\n\nUsing your SB.py script, add a while loop that repeats the program indefinitely. You can use while True: to start the loop. Add an if-statement such that if any of the inputs are quit, q, or exit, the loop breaks.\n\nAs a bonus: check if the inputs are the correct (float) types and prompt the user again if they are not.\n\nIntially, you might not see this looping business as incredibly useful but lets take a more complicated example...\n\n# Define the height of the tree\nheight = 5\n\n# Using a for loop to print a Christmas tree\nfor i in range(1, height + 1): \n    spaces = \" \" * (height - i)\n    stars = \"*\" * (2 * i - 1)\n    print(spaces + stars)\n\nThis would be kind annoying to print out by actually typing out the spaces and the stars, especially if you want to make the tree larger..\n\n# Define the height of the tree\nheight = 12\n\n# Using a for loop to print a Christmas tree\nfor i in range(1, height + 1): \n    spaces = \" \" * (height - i)\n    stars = \"*\" * (2 * i - 1)\n    print(spaces + stars)\n\nAbove we have the range function which creates a “range” instance. This is another example of an iterable\n\n","type":"content","url":"/loop#part-1-for-loops-and-while-loops","position":3},{"hierarchy":{"lvl1":"Looping in Python","lvl2":"Part 2: Iterables"},"type":"lvl2","url":"/loop#part-2-iterables","position":4},{"hierarchy":{"lvl1":"Looping in Python","lvl2":"Part 2: Iterables"},"content":"Okay so now that we have the basic syntax of these two loops, lets talk iterables. Lets start with a list\n\nmy_grocery_list = [\"apples\", \"oranges\", \"dorritos\", \"mustard\", \"eggs\", \"gummy bears\"] \n# pay attention to the syntax here! ([] square brackets!)\n\nhow many things do I have in my list? and what is each element? and can I iterate over these random things that aren’t integers?\n\nprint( len(my_grocery_list) )\n\nprint( type(my_grocery_list[2]))\n\nfor food in my_grocery_list[3:5]:\n    print(\"oh shoot I forgot the\", food)\n\nAs we can see there are 6 str elements in the list and iterating over the 3rd and 4th element is perfectly easy!\n\nIn other words the iterable can be an interger, a string, a list itslef, basically any data type! Lets now loop over a dictionary!\n\n# Define a treasure map dictionary\ntreasure_map = {\n    'Start': 'You find yourself on a mysterious island.',\n    'Palm Tree': 'Under the palm tree, you discover a clue written in the sand.',\n    'Cave Entrance': 'Following the clue, you reach the entrance of a dark cave.',\n    'Treasure Room': 'After navigating through the cave, you discover the hidden treasure room!',\n    'X marks the spot': 'You find the treasure chest buried under a giant \"X\" on the floor.'\n}\n\n# Use a for loop to explore the treasure map\nfor location, description in treasure_map.items():\n    print(f'You are at {location}: {description}')\n    user_input = input('Do you want to continue the adventure? (yes/no): ')\n    \n    if user_input.lower() != 'yes':\n        print('Thanks for playing! Adventure complete.')\n        break\n\n","type":"content","url":"/loop#part-2-iterables","position":5},{"hierarchy":{"lvl1":"Looping in Python","lvl2":"Part 3: Double for-loops ... Tread carefully!"},"type":"lvl2","url":"/loop#part-3-double-for-loops-tread-carefully","position":6},{"hierarchy":{"lvl1":"Looping in Python","lvl2":"Part 3: Double for-loops ... Tread carefully!"},"content":"\n\nPretend you are sampling ages by asking 10 random people in the grocery store.\n\nYou do this expirement three times in the same grocery store on Monday, Tuesday and Wednesday.\n\nYou now have three lists of numbers that (rather conviently) are the same length.\n\nlist_Mon = [5, 12, 3, 5, 67, 1, 2, 34, 2, 89]\n\nlist_Tues = [15, 45, 21, 2, 8, 9, 54, 99, 17, 51]\n\nlist_Wed = [32, 65, 11, 9, 5, 75, 21, 14, 39, 71]\n\nNow lets say you wanted to know if any of these people could have been around to see the 2001 superbowl. How would you go about doing so?\n\nmin_age = 2023 - 2001\nlist_Mon > min_age\n\nwell that doesn’t seem to work! so maybe we use a handy loop!\n\nbool_Mon = []\nfor i in list_Mon:\n    bool_Mon.append(i > min_age)\n\nprint(bool_Mon)\nprint(\"only \" +str(sum(bool_Mon)) + \" people are old enough!\")\n\nokay but what about the other days? Maybe we iterate over a list of lists?\n\nall_ages = [list_Mon, list_Tues, list_Wed]\nall_bool = []\n\nfor list in all_ages:\n    for i in list:\n        all_bool.append(i > min_age)\n\n\nprint(all_bool)\nprint(\"only \" +str(sum(all_bool)) + \" people are old enough!\")\n\nGreat so the double for-loop seems to work fine!, but lets say it wasn’t just 10 people each day, and it wasn’t just for three days.\n\nInstead, lets say you and your friends talked to 100,000 people each day for 10 years (10x365 days)\n\nNow since I can’t generate that many numbers on the spot I will use the numpy.random package. We will discuss this more later...\n\nall_ages_BIG = np.random.randint(0,100, size=(3650,100000)).tolist()\n\nlets try the same scheme as before with the double for-loop!\n\nall_bool_BIG = []\n\nfor list in all_ages_BIG:\n    for i in list:\n        all_bool_BIG.append(i > min_age)\n\nprint(\"10^\" +str(np.log10(sum(all_bool_BIG))) + \" people are old enough!\")\n\nthat is A LOT of people! so much so that it took our computer ~43 seconds to compute that number!\n\nworst of all this is for a relatively simple operation! anything slightly more complicated would greatly impact the preformance of this scheme.\n\nWe can do a lot better than that (namely by using numpy arrays)\n\nall_ages_BIG = np.random.randint(0,100, size=(3650,100000))\n\nwow = np.sum(all_ages_BIG > min_age)\n\nprint(\"10^\" +str(np.log10(wow)) + \" people are old enough!\")\n\nthat only took 3 seconds! so be careful when constructing these seemingly harmless tools and remember double-for loops are a LAST RESORT!","type":"content","url":"/loop#part-3-double-for-loops-tread-carefully","position":7},{"hierarchy":{"lvl1":"Functions in Python"},"type":"lvl1","url":"/functions","position":0},{"hierarchy":{"lvl1":"Functions in Python"},"content":"Functions in programming languages work the say way as in mathematics. For example, you will be familiar with trigonometric functions:f(x) = sin(x)\n\nIn this case, we have some function, f, which has parenthesis defining its arguments (in this case, x). In this case, we are returning sin(x), though we could have constructed an arbitrary function of other functions, e.g., f(x) = sin(x)cos^2(x).\n\nNote\n\nAs a reminder, we are already using functions in Python all the time --- we are simply using functions built into the language, such as the list() function to generate a list, or the np.min() function to return the minimum value from some collection.\n\nNow let’s define a Python function. Let’s make a function that returns the combination of sin and cos squared above.\n\nimport numpy as np\ndef f(x):\n    answer = np.sin(x)*np.cos(x)**2 \n    return answer\n\nHere we are using the special Python reserved word def to define the name of the function (here f), and in parenthesis, we add the arguments to the function (here x). We end the line in a colon (much like a loop).\n\n“Inside” the function, we indent our code (four spaces or a tab) and then place any computations we want to carry out. Here, we compute answer to be the multiplication of our two trig functions.\n\nFinally, we use the reserved word return to “return” this answer from the inside of the function back out into the rest of our code.\n\nNote\n\nThis has to do with something called scope, which we will get to shortly\n\nTo use our function, we simply call it:\n\nreturned_answer = f(0.5)\nprint(returned_answer)\n\nAs we can see, the answer from the function gets stored in the variable returned_answer as the output of the function. This should look familiar to how you call any Python function (including those imported from libraries, though they may be prepended with the library name, e.g., np.function()).\n\nNote\n\nWhile we first compute answer in the function, then return it, we could have simply returned the calculation (as it was one line), e.g.,def f(x):\n    return np.sin(x)*np.cos(x)**2\n\n","type":"content","url":"/functions","position":1},{"hierarchy":{"lvl1":"Functions in Python","lvl2":"Scope"},"type":"lvl2","url":"/functions#scope","position":2},{"hierarchy":{"lvl1":"Functions in Python","lvl2":"Scope"},"content":"\n\nFunctions are useful for many reasons. To list some obvious ones, they allow a calculation to be encapsulated and the code reused. If we need the output of that multiplication many times in our code, we can call f(x) instead of writing out np.sin(x)*np.cos(x)**2. Now in this case, that’s not so bad --- but we can write functions with many more steps (lines of code).\n\nBeyond that, functions are useful due to their local scope. What does that mean?\n\nSo far, when we have written scripts in python, we define variables directly on lines of the file (or in the interpreter). At any later time, we can access those variables via their names.\n\nExercise\n\nTry running print(answer), to get the value of the variable we defined in our function.\n\nYou should find that we can’t!\n\nprint(answer)\n\nThe reason answer is not defined is because any variable defined inside a function is local only to that function. You can think of it like an automotive assembly line at a factory. Raw materials (the arguments) enter at one end, the factory uses a set of screws, bolts, etc., to build the car, and the final car is returned. We are not concerned with the steps that happened inside the factory, and those variables (like tools) are reused every time the function is called.\n\nMore formally, Python defines several levels of scope. Scope defines where a variable is allocated and accessible. Variables made in a Python script are in the scope of that module. When you run that script, your interpreter can access any variable you made in the script.\n\na = 10 \nb = 20\n\nprint(a)\nprint(b)\n\nFunctions define their own local scope, which is limited just to the function. Variables made there only “exist” inside the function. That said, a function can retrieve variables from a larger scope:\n\na = 10 \ndef f(x):\n    return a + x\n\nprint(f(10))\n\nDanger\n\nIt is generally considered bad practice to use variables from a larger scope than the function within a function. Think about it: Functions are beneficial because they are self-contained units of callable code. We should be able to, for example, copy and paste our function into a different file and use it there. If the function relies explictly on variables outside the function, we can’t do this.\n\n","type":"content","url":"/functions#scope","position":3},{"hierarchy":{"lvl1":"Functions in Python","lvl2":"Type Annotations and Docstrings"},"type":"lvl2","url":"/functions#type-annotations-and-docstrings","position":4},{"hierarchy":{"lvl1":"Functions in Python","lvl2":"Type Annotations and Docstrings"},"content":"\n\nSo far, we’ve defined our functions minimally. But there are two steps we can take to make our functions better documented. Documentation is extremely important in code; we’ve covered comments, and this is the next step for making clear the behavior of our code. Let’s start with a new, slightly more complex function:\n\ndef kepler_period(sma_au):\n    return np.sqrt(sma_au**3/7.496e-6)\n\nkepler_period(1) #should give earth's year in days!\n\nTechnically, this function is already more documented than our previous functions, because its name and arguments are clearer in defining what they should be. But we can do more. First, we will annotate the arguments:\n\ndef kepler_period(sma_au:float)->float: \n    return np.sqrt(sma_au**3/7.496e-6)\n\nWe add a colon to each argument and specify the type (for example, float, int, str, dict), and at the end, we use an arrow (->) to indicate the return type of the function, before the final colon.\n\nWarning\n\nBy default, Python does not enforce on execution that your inputs to functions match their type annotations. But external packages (like mypy or pydantic) can be used with your code to do this.\n\nWe’ll return to deeper questions about type annotations later (e.g., what if multiple types are acceptable?)\n\nFor now, let’s add a docstring --- this is a specialized string within our function which can be used to verbose-ly define its arguments and returns.\n\ndef kepler_period(sma_au:float)->float: \n    \"\"\"\n    Returns the orbital period (in days) for solar system bodies given their semimajor axis length (in AU).\n\n    Parameters\n    ----------\n    sma_au: float\n        body's semimajor axis (sma) in AU units \n    \n    Returns\n    -------\n    period: float\n        the orbital period (in days). \n    \"\"\"\n    return np.sqrt(distance_au**3/7.496e-6)\n\nThe docstring, defined with triple quotes (which allows multiline strings) now gives a sentence-long description of the function, defines the arguments and returns, and their data types, as well as notating optional arguments and indicating their default values. For a one line function, this is a bit overkill, but for functions you write for your research, it can be very useful to have good documentation. We can see the documentation for any Python function via the help() function:\n\nhelp(kepler_period)\n\nThere’s even more we can add. For example, the docstring for any numpy function will be very verbose:\n\nimport numpy as np\nhelp(np.argmax)\n\nYou can see the formatting is the same, but there are extra sections. You are welcome to add these to your own functions, but that is likely not neccesary until you begin distributing your code to others to use.\n\n","type":"content","url":"/functions#type-annotations-and-docstrings","position":5},{"hierarchy":{"lvl1":"Functions in Python","lvl2":"Optional Arguments"},"type":"lvl2","url":"/functions#optional-arguments","position":6},{"hierarchy":{"lvl1":"Functions in Python","lvl2":"Optional Arguments"},"content":"\n\nThus far, our kepler function has only one argument: the semimajor axis. This is possible because we use the constant slope derived for kepler’s laws that is specific to our solar system (depends on the Sun’s mass) and our universe (depends on the magnitude of the gravitational constant G).\n\nThe formula itself for Kepler’s third law is\\frac{a^3}{P^2} = \\frac{G(M+m)}{4\\pi^2} \\approx \\frac{GM}{4\\pi^2}\n\nLet’s implement this in our function, but not require the user to supply M and G by default:\n\ndef kepler_period(sma_au:float,\n                  star_mass: float = 1.989e+30,\n                  G: float = 6.674e-11)->float: \n    \"\"\"\n    Returns the orbital period (in days) for solar system bodies given their semimajor axis length (in AU).\n\n    Parameters\n    ----------\n    sma_au: float\n        body's semimajor axis (sma) in AU units \n    star_mass: float, optional\n        mass of the stellar (dominating) body, in kg, default 1.989e30 (sun's mass)\n    G: float, optional\n        gravitational constant in SI units, default 6.674e-11\n    Returns\n    -------\n    period: float\n        the orbital period (in days). \n    \"\"\"\n    sma_meters = 1.496e+11 * sma_au \n    P_squared = (4*np.pi**2*sma_meters**3)/(G*star_mass)\n    return np.sqrt(P_squared)*1.15741e-5\n\nLet’s test that our function can still work with just a sma_au provided (and of course that it is still correct!)\n\nkepler_period(1)\n\nWith a bit of extra unit massaging (putting everything in SI units, then converting the end result from seconds to days), we see we get earth’s period out accurately. However, if we wished, we could now start playing with solar system parameters:\n\nkepler_period(1,star_mass=5e30)\n\nSo if our sun were 5\\times10^{30}\\; \\rm kg rather than  2\\times10^{30}\\; \\rm kg, the earth’s year would only be 230 days long.\nNotice that because star_mass is a non-positional argument, we had to give its name explicitly when adding it in. This is why optional arguments are also called keyword arguments --- we can give some, none, or all, and in any order (after the positional arguments).\n\nWarning\n\nWhen defining a function that has both positional (required) and optional arguments, the positional arguments must come first, Thus,def func(a,b,c=1,d=3):\n    ...\n\nis legal, butdef func(a=2,b,c,d):\n    ...\n\nis not.\n\nAs a (quick) preview of what is to come, here’s that same function again, but I’ll allow the astropy package to handle all the unit conversions for us:\n\nimport astropy.units as u \nimport astropy.constants as ac\ndef kepler_period(sma:u.Quantity,\n                  star_mass: u.Quantity = 1*u.Msun,\n                  G: u.Quantity = ac.G)->u.Quantity: \n    \"\"\"\n    Returns the orbital period (in days) for solar system bodies given their semimajor axis length in any length units.\n\n    Parameters\n    ----------\n    sma: u.Quantity\n        body's semimajor axis (sma) in any length units\n    star_mass: u.Quantity, optional\n        mass of the stellar (dominating) body, in any mass units\n    G: u.Quantity, optional\n        gravitational constant in any appropriate units.\n    Returns\n    -------\n    period: u.Quantity\n        the orbital period (in days). \n    \"\"\"\n    P_squared = (4*np.pi**2*sma**3)/(G*star_mass)\n    return np.sqrt(P_squared).to(u.day)\n\nprint(kepler_period(sma=2.1*u.AU, star_mass=2*u.Msun))\nprint(kepler_period(sma=1*u.AU))\n\n","type":"content","url":"/functions#optional-arguments","position":7},{"hierarchy":{"lvl1":"Functions in Python","lvl2":"Extra arguments and keyword arguments, Packing, and Unpacking"},"type":"lvl2","url":"/functions#extra-arguments-and-keyword-arguments-packing-and-unpacking","position":8},{"hierarchy":{"lvl1":"Functions in Python","lvl2":"Extra arguments and keyword arguments, Packing, and Unpacking"},"content":"\n\nIn some cases, it is useful to define a function which takes in an arbitrary set of arguments.\nFor example, if the output of a previous function produces an unknown number of items, we may wish to admit all of them to the next function we call.\n\nWe will handle this using a Python technique known as packing (and unpacking).\nThis is a special operation that allows iterables (e.g. lists or dictionaries) to be created from function argument lists, or to be turned into inputs to a function.\n\nLet’s see an example:\n\nargs = [1,2,3]\nmagnitude(*args)\n\nWhat happened here? Our magnitude() function, recall, takes 3 inputs. But args is a single list.\nUnder the hood, the asterisk in the function call tells Python to unpack the list and feed each value as a separate argument to the function, in order.\n\nWe can play a similar game with dictionaries --- here, we will need a double-asterisk:\n\nkwargs = {'flux_1':1,'flux_2':2,'zeropoint':3}\nmagnitude(**kwargs)\n\nEssentially, **kwargs in the function call gets translated to flux_1=1,flux_2=2,zeropoint=3, as we would normally provide the function.\n\nThese are examples of unpacking a single object into parts to feed into a function. What about the reverse?\nLet’s start with an example:\n\ndef dist_from_parallax(*args):\n    \"\"\"Simple function to return distance (pc) from a parallax (in ''). \n    Takes any number of input parallaxes and returns a list of distances.\n    \"\"\"\n    return_list = []\n    for parallax in args:\n        return_list.append(1/parallax)\n    return return_list\n\nWhen we use the asterisk operator in the definition of a functions arguments, we do the reverse of the unpacking above.\nHere, we take any inputs to the function (an arbitrary number of inputs), and pack them into a list we are calling args.\nThat list args is available inside the function, where we loop over it to calculate distances from the inputs (assuming they are parallaxes).\n\ndist_from_parallax(1)\n\ndist_from_parallax(1.6,4.5,3.2,7.6,10.1)\n\nNote\n\nIn practice, it would probably better to write this function to expect a single iterable (list or array), and to do the calculation in a vectorized way.\n\nWe can play the same game with keyword arguments (i.e., pack extra arguments given with names (like star_mass=10*u.Msun) into a dictionary accessible in the function.\nHere I’ll use an example more typical --- adding kwargs to a function that already has some arguments.\n\ndef get_solarsystem_periods(semi_major_axes:list,**kwargs)->list:\n    periods = []\n    for i in semi_major_axes:\n        periods.append(kepler_period(i,**kwargs))\n    return periods\n\nHere, I’ve made what a coder would call a wrapper. This function’s goal is to get the periods for a list of input semimajor axes (i.e., feed in the sma for Mercury, Venus, Earth,...), then spit out a list with all the periods.\n\nWe know that our kepler_period() function needs that one input (here, fed in from the loop as i), but that it can take extra parameters for the star mass and gravitational constant. Instead of making those explicit arguments of our wrapper, we can use **kwargs to tell it to take any extra arguments and make a dictionary out of them.\n\nInside our function, there is now a variable called kwargs which is a dictionary. We could do stuff with it here, if we desired. But I simply pass it into our internal call to kepler_period(). Note that I use the ** operator again, now to unpack that dictionary back into functional arguments.\n\nWarning\n\nCan you see a way this could currently go wrong? There is a circumstance when passing kwargs to our wrapper that will generate an error.\n\nSee Answer\n\nBecause kepler_period() does not accept arbitrary kwargs, if we ran get_solar_system_periods([1*u.AU,2*u.AU],star_mass=10*u.Msun,bad_arg=10), we would get an error because bad_arg would be passed to kepler_period() which does not have that argument defined.\n\nWe could stay safe from this by adding **kwargs as an argument to kepler_period(), then any proper (defined) kwargs would be caught, and extra ones would get shoved into a dictionary that could be safely ignored.\n\n","type":"content","url":"/functions#extra-arguments-and-keyword-arguments-packing-and-unpacking","position":9},{"hierarchy":{"lvl1":"Functions in Python","lvl2":"Summary"},"type":"lvl2","url":"/functions#summary","position":10},{"hierarchy":{"lvl1":"Functions in Python","lvl2":"Summary"},"content":"\n\n","type":"content","url":"/functions#summary","position":11},{"hierarchy":{"lvl1":"Functions in Python","lvl3":"Summary","lvl2":"Summary"},"type":"lvl3","url":"/functions#summary-1","position":12},{"hierarchy":{"lvl1":"Functions in Python","lvl3":"Summary","lvl2":"Summary"},"content":"Functions allow us to encapsulate short (ish), general tasks into a clean, easy to debug framework\n\nBecause of their local scope, we can be sure all variables passed through are treated the same way\n\nFunctions take arguments, including required (positional) and optional (keyword) ones.\n\nOne can use *args and **kwargs to allow arbitrary inputs, or to unpack lists and dicts into function calls","type":"content","url":"/functions#summary-1","position":13},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!"},"type":"lvl1","url":"/hunt","position":0},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!"},"content":"","type":"content","url":"/hunt","position":1},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl2":"Introduction"},"type":"lvl2","url":"/hunt#introduction","position":2},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl2":"Introduction"},"content":"Welcome to the Unix Scavenger Hunt! This activity is designed to help you explore and become more comfortable with Unix commands. Each prompt is a mini adventure where you’ll use the terminal to accomplish specific tasks. Feel free to try the challenge in any order!","type":"content","url":"/hunt#introduction","position":3},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl2":"Rules"},"type":"lvl2","url":"/hunt#rules","position":4},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl2":"Rules"},"content":"You can use Google and other resources to find the commands and solutions, but try using man and -h first to see if the documentation makes sense!\n\nMake sure to write down/document the commands you use and what those commands do. We will go around and share what we learned at the end of the class time.\n\nTry to stick to terminal - don’t use your machine’s GUI to get to the solutions!\n\nHave fun and enjoy the exploration!\n\nOne General Tip!\n\nThe man command (stands for manual) prints detailed help information for unix commands and can help you throughout this exercise! You can call up the manual for a command like so: man ls. This opens a vim like editor that you can scroll through (with your mouse or arrow keys depending on your terminal set up). To exit the manual, press q.\n\n","type":"content","url":"/hunt#rules","position":5},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl2":"Scavenger Hunt Challenges"},"type":"lvl2","url":"/hunt#scavenger-hunt-challenges","position":6},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl2":"Scavenger Hunt Challenges"},"content":"We are sharing a folder with all of you via Slack. Everyone should download a copy of this folder onto their machine for this exercise.\n\n","type":"content","url":"/hunt#scavenger-hunt-challenges","position":7},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl3":"Challenge 1: The Hidden Treasure","lvl2":"Scavenger Hunt Challenges"},"type":"lvl3","url":"/hunt#challenge-1-the-hidden-treasure","position":8},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl3":"Challenge 1: The Hidden Treasure","lvl2":"Scavenger Hunt Challenges"},"content":"Find a file named “treasure.txt.” Navigate to it, retrieve the contents of the file, and share what you’ve discovered!\n\nOpen for Hint\n\nHere are some ideas:\n\nConsider the grep command!\n\nYou can use cat, less, or more to view the contents of a file. Like for man, close the opened program by hitting q.\n\nHard Mode: try using an editor like vim or nano to read the file!\n\n","type":"content","url":"/hunt#challenge-1-the-hidden-treasure","position":9},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl3":"Challenge 2: Mysterious Sizes","lvl2":"Scavenger Hunt Challenges"},"type":"lvl3","url":"/hunt#challenge-2-mysterious-sizes","position":10},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl3":"Challenge 2: Mysterious Sizes","lvl2":"Scavenger Hunt Challenges"},"content":"Try to find the directoy with the biggest size in the folder we shared with you. Now try to find the largest individual file. Share the directory name (and/or file name), size, and the command you used to find it.\n\nOpen for Hint\n\nHere are some ideas:\n\nLook into available flags for the ls command\n\nConsider the du command, and play around with which flags you can use!\n\n","type":"content","url":"/hunt#challenge-2-mysterious-sizes","position":11},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl3":"Challenge 3: The Time Traveler","lvl2":"Scavenger Hunt Challenges"},"type":"lvl3","url":"/hunt#challenge-3-the-time-traveler","position":12},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl3":"Challenge 3: The Time Traveler","lvl2":"Scavenger Hunt Challenges"},"content":"Find a file with a modification date that is at least one month ago and change its timestamp!\n\nOpen for Hint\n\nHere are some ideas:\n\nRecall we can us ls -l to view file details\n\nConsider the touch command!\n\n","type":"content","url":"/hunt#challenge-3-the-time-traveler","position":13},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl3":"Challenge 4: The Artist","lvl2":"Scavenger Hunt Challenges"},"type":"lvl3","url":"/hunt#challenge-4-the-artist","position":14},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl3":"Challenge 4: The Artist","lvl2":"Scavenger Hunt Challenges"},"content":"Create a new directory named “masterpiece” and populate it with text files, each containing a line from your favorite quote or poem. Use an editor (either vim or nano, but I recommend vim!) to make your files. Share the commands you used to create and populate the directory.\n\nThen, use a command to print out all your lines of poetry (across the files) one after the other.\n\nOpen for Hint\n\nHere are some ideas:\n\nUtilize commands like mkdir to create folders. You can use vim to generate files!\n\nConsider the cat command to print your poems!\n\nFor printing all lines, there is a way with both grep and head, both of which use the wildcard *!\n\n","type":"content","url":"/hunt#challenge-4-the-artist","position":15},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl3":"Challenge 5: Pipe Explorer","lvl2":"Scavenger Hunt Challenges"},"type":"lvl3","url":"/hunt#challenge-5-pipe-explorer","position":16},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl3":"Challenge 5: Pipe Explorer","lvl2":"Scavenger Hunt Challenges"},"content":"Navigate to a directory containing multiple text files. Use a combination of commands and piping to find and count the number of lines in each text file. Share your results, showing the filename and the corresponding line count for each text file.\n\nOpen for Hint\n\nHere are some ideas:\n\nConsider using find to locate text files and wc -l to count lines.\n\n","type":"content","url":"/hunt#challenge-5-pipe-explorer","position":17},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl2":"Conclusion"},"type":"lvl2","url":"/hunt#conclusion","position":18},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl2":"Conclusion"},"content":"Remember, the goal is to have fun and gain hands-on experience with Unix commands. Feel free to experiment and explore beyond the prompts. Happy scavenger hunting!","type":"content","url":"/hunt#conclusion","position":19},{"hierarchy":{"lvl1":"Calculating the Luminosities of Stars"},"type":"lvl1","url":"/week1-lab-2025","position":0},{"hierarchy":{"lvl1":"Calculating the Luminosities of Stars"},"content":"Now, we can put together everything we’ve learned so far to build a useful script.  We’ll do so in the context of the properties of stars.\n\n1. The Stefan-Boltzmann Law\n\nStars, to zeroth order, can be considered spherically-symmetric blackbodies. Under those conditions, their luminosities can be computed via the Stefan-Boltzmann law,L = 4\\pi R^2 \\sigma T^4\n\nwhere R is the radius, T is the effective temperature of the Star, and σ is the Stefan-Boltzmann constant, \\sigma = 5.67 * 10^{-8} \\rm \\ W/m^{2}/K^{4}.\n\nThe goal of today’s lab is to implement this in Python, i.e., write a code to calculate the Luminosity (L) of a star according to the formula described above. The rough steps are as follows:\n\nCreate a new code file called “SB.py” using the Terminal.\n\nWithin SB.py, define a unique variable for each of π, σ, R, and T. For now, assume \\pi = 3.14, R = 7 * 10^8 meters and T = 5776 K.  You can assume the units work out (and therefore you can ignore them in Python).\n\nUsing basic mathematical operations, compute the value of L according to the formula above using the variables you just defined. Store the result in a new variable. (Hint: powers in python are implemented via the ** operator, e.g., 6**2 = 36)\n\nUsing f-strings, print the result in a sentence that looks like:\nThe Luminosity of a star with effective temperature [value of T] and radius [value of R] is [value of L].\n\nTest the script by running it from the terminal. Outside of Python, compare your luminosity value to the Solar luminosity, 3.8 * 10^{26} Watts. Is your value greater, less than, or equal to the Solar luminosity?\n\nRather than simply hardcoding the value of T and R in your script, use the input() function to allow you to provide the values in the terminal at runtime.\n\nImplement the comparison to the Solar Luminosity in your code and store the result a new boolean (True/False) variable called supersolar. Then extend your f-string above to print whether the star is more luminous than the Sun. The output should look like: The Luminosity of a star with effective temperature [value of T] and radius [value of R] is [value of L]. It is [value of supersolar] that this is more luminous than the Sun.\n\n2. Practice with List Indexing\n\nLet’s imagine you have data for bright stars that looks a bit like:star_names = [\"Sirius\", \"Canopus\", \"Rigil Kentaurus\", \"Arcturus\", \"Vega\", \"Capella\", \"Rigel\", \"Procyon\", \"Achernar\", \\ \n\"Betelgeuse\", \"Acrux\", \"Altair\", \"Aldebaran\", \"Spica\", \"Antares\", \"Pollux\", \"Fomalhaut\", \"Deneb\", \"Regulus\", \"Adhara\"]\n\nstar_temperatures =  [9940, 7400, 5800, 4300, 9600, 4900, 12100, 6550, 14600, 3500, 28000, 7700, 3900, 22200, 3400, 4940, 8550, 8525, 12300, 20800]\n\nstar_radii = [1.711e9, 7.8e8, 1.227e9, 2.785e9, 2.364e9, 1.192e9, 7.6e8, 7.43e8, 1.586e9, 9.52e10, 6.01e9, 1.656e9, \\ \n4.28e9, 7.739e8, 8.12e9, 1.927e9, 1.834e9, 8.48e9, 3.919e9, 4.66e9]\n\nCreate a new script called star_calcs.py.\n\nUsing indexing, figure out: what the name of the tenth star in this list? Then, store the index in a variable.\n\nNow, using the stored index, isolate the temperature of the star by accessing the appropriate element of the second list.\n\nRepeat step 2 for the radius.\n\nBy copy-pasting your formula implementation from exercise 1 into your new script, compute the luminosity of the star of the tenth star.\n\nNow that we’ve finished with star 10, let’s try to make it our code more generally applicable.\n\nHave your program take an index in via input() and run the calculation for the star corresponding to that index.\n\n(BONUS): Create a dictionary for each of the two properties for the first 5 stars above (that is, a dictionary for radius and a dictionary for temperature). The keys should be the star names.\n\n(BONUS part 2): Now have your program take the star name as an input and print the name, temperature, radius, and computed luminosity in a nicely formatted sentence.","type":"content","url":"/week1-lab-2025","position":1},{"hierarchy":{"lvl1":"Lab 2: Practicing Numpy and Discovering New Modules, Packages, and Functions!"},"type":"lvl1","url":"/lab2-2025","position":0},{"hierarchy":{"lvl1":"Lab 2: Practicing Numpy and Discovering New Modules, Packages, and Functions!"},"content":"We’ll start with the basic exercises that we begun in the Week 2 workshop session.\n\nExercise 1a: Array Generation and Statistics\n\nGenerate an array called a of 1000 evenly spaced numbers between -50 and 2000.\n\nCompute and print the mean, standard deviation, and median of a.\n\nCompute and print the 16th and 84th percentiles of a.\n\nExercise 1b: Random Values and Operations\n\nGenerate an array called b of 1000 random values between 0 and 1.\n\nCompute and store:\n\nThe product of a and b in c.\n\nThe division of a by b in d.\n\nPrint the arrays c and d.\n\nCompute and print the mean and standard deviation of c and d.\n\nNow, let’s apply them in a more interesting context:\n\nExercise 2: Deriving the Distance to a Globular Star Cluster with Parallax Measurements\n\nIn this exercise, we will estimate the distances to stars in a globular cluster using the parallax method. As you go about doing the steps below, you’ll find that you need to look up various functions within numpy to answer the questions. That’s intentional: practicing this will help you get comfortable with reading documentation!","type":"content","url":"/lab2-2025","position":1},{"hierarchy":{"lvl1":"Lab 2: Practicing Numpy and Discovering New Modules, Packages, and Functions!","lvl2":"Background: Globular Clusters"},"type":"lvl2","url":"/lab2-2025#background-globular-clusters","position":2},{"hierarchy":{"lvl1":"Lab 2: Practicing Numpy and Discovering New Modules, Packages, and Functions!","lvl2":"Background: Globular Clusters"},"content":"A globular cluster is a spherical collection of old stars that are gravitationally bound. These clusters can contain thousands to millions of stars, all of which share a common origin and age. Because they are bound objects, and are compact (~a few parsec in size) compared to their distances (>> 1 kpc in the Milky Way), all of their stars can be considered as being equidistant from us to good approximation.","type":"content","url":"/lab2-2025#background-globular-clusters","position":3},{"hierarchy":{"lvl1":"Lab 2: Practicing Numpy and Discovering New Modules, Packages, and Functions!","lvl2":"Background: Parallax Measurements"},"type":"lvl2","url":"/lab2-2025#background-parallax-measurements","position":4},{"hierarchy":{"lvl1":"Lab 2: Practicing Numpy and Discovering New Modules, Packages, and Functions!","lvl2":"Background: Parallax Measurements"},"content":"Parallax is the apparent shift in the position of an object when viewed from different angles. It’s commonly used in astronomy to measure distances to stars by observing their position from two points in Earth’s orbit.\n\nThe relationship between parallax shift/angle  \\varpi  (in arcseconds, which is a unit of angle) and distance  d  (in parsecs) is:d = \\frac{1}{\\varpi}\n\nwhere  d  is in units of parsecs and  \\varpi  is in arcseconds.\n\nIn theory, the stars in a globular cluster should all have the same parallax, since the stars are roughly equidistant from us. However, in practice, measurements of parallax angles can be noisy due to observational errors.  In this problem, we’ll explore the implications of that for measuring the distances to clusters.","type":"content","url":"/lab2-2025#background-parallax-measurements","position":5},{"hierarchy":{"lvl1":"Lab 2: Practicing Numpy and Discovering New Modules, Packages, and Functions!","lvl2":"Your Task"},"type":"lvl2","url":"/lab2-2025#your-task","position":6},{"hierarchy":{"lvl1":"Lab 2: Practicing Numpy and Discovering New Modules, Packages, and Functions!","lvl2":"Your Task"},"content":"Create a numpy array of fixed parallax values, each with a parallax of  0.001  arcseconds. The array should have a length of 100 (simulating 100 stars in the globular cluster). You don’t need to give units to the array, but consider naming the variable something that mentions this information.\n\nSimulate Noisy Parallax Measurements:\n\nFor each star, simulate a noisy parallax measurement by adding random noise to the true parallax value. Specifically, use numpy to add Gaussian (normal) noise with a mean of 0 and a standard deviation of  0.0005  arcseconds (this represents measurement uncertainty).\n\nCompute the Distances to Individual Stars:\n\nUse the formula above to compute an array of distances to the stars based on the array of noisy parallax angles.\n\nCompute the Cluster Distance with Uncertainties:\n\nCalculate the mean distance across all the stars.\n\nCalculate the standard deviation of the distances.\n\nCompute the 68% confidence interval for the distance distribution by using numpy.percentile. Hint: what percentiles could you use to select for the central 68% of the distribution?\n\nUse your results and known conversion factors to translate your answer to units of lightyears\n\nInterpretation\n\nPrint the noisy parallax values, the computed distances, and the statistical results (mean distance, standard deviation, and confidence interval).\n\nHow does the derived mean distance compare to the value that you get if you simply inverted the known parallax of 0.001 arcseconds? Explain a bit why your answer makes sense\n\nWe’ll return to do this with real data at a later date!","type":"content","url":"/lab2-2025#your-task","position":7},{"hierarchy":{"lvl1":"Week 3 Lab: Program Flow, Logic, and Loops with the Messier Catalog!"},"type":"lvl1","url":"/lab3-2025","position":0},{"hierarchy":{"lvl1":"Week 3 Lab: Program Flow, Logic, and Loops with the Messier Catalog!"},"content":"In this assignment, you will practice using logic and loops using a dataset of objects from the \n\nMessier Catalog. The dataset includes basic information about each object, like it’s type, magnitude, distance, constellation, and the best viewing season. Your tasks will involve reading the data, analyzing it, and using numpy, logic, and loops to answer questions about it!\n\n","type":"content","url":"/lab3-2025","position":1},{"hierarchy":{"lvl1":"Week 3 Lab: Program Flow, Logic, and Loops with the Messier Catalog!","lvl2":"Opening the Dataset"},"type":"lvl2","url":"/lab3-2025#opening-the-dataset","position":2},{"hierarchy":{"lvl1":"Week 3 Lab: Program Flow, Logic, and Loops with the Messier Catalog!","lvl2":"Opening the Dataset"},"content":"The data is stored in a .npy file, which you can load with np.load(). We will provide this .npy file via slack, and you can use the following line of code to open up the file in your code and store it’s contents in a variable called data.data = np.load('/Users/yasmeenasali/Downloads/messier_data.npy')\n\nCaution\n\nWill the above line run on your computer? No! Do you remember what you need to change about it?\n\nHint\n\nRecall from Week 0, you need to update the PATH to match where the data lives on your computer! You can put the data anywhere on your computer, and specify the absolute PATH in your code like the example I have above. Alternately, if you put the data in the same directory (folder) as the python script you are writing, you can open it like this: np.load(messier_data.npy).\n\nEach row in the dataset corresponds to a single Messier object, with the following fields:\n\nMessier: Name of the Messier object as a string (e.g., 'M107', 'M108')\n\nRA and DEC: the Right Ascension and Declination of the object (coordinates in the sky).\n\nType: Type of object (e.g., 'Gc' for Globular Cluster, 'Sp' for Spiral, 'Ba' for Barred Spiral)\n\nMag: Magnitude (brightness) of the object. Magnitudes are a unit-less system, and lower numbers mean brighter objects!\n\nDistance: Distance from Earth in units of light-years\n\nConstellation: The constellation in which the object resides\n\nSeason: The best viewing season (spring, summer, autumn, winter)\n\nSince we have not practiced with large 2D datasets a lot, here are some tips and reminders.\n\nYou can access each row of the dataset using indexing. For instance, data[0] will return the first row of the array (aka all of the above column values for a single Messier object).\n\nYou can access each column of the dataset using data['Messier'] for example, where now rather than indexing by an integer we are indexing by a column key (a column name). This will return a numpy array of all the Messier numbers for all of the objects.\n\nExercise One: Overview Analysis of the Messier Catalog\n\nThese problems are reviewing skills from last week and from this week’s lecture! Hopefully, they are on the easier side!\n\nHow many objects are in the dataset? You can either write a loop to count the number of objects or use a built-in python function.\n\nInvestigate the brightness of Messier objects: Recall that magnitude is a measure of brightness, and brighter objects have lower magnitude values!\n\nCalculate the average magnitude of all the Messier objects.\n\nWhat magnitude is the brightest object in the catalog, and what magnitude is the dimmest?\n\nOnce you have that, calculate the difference in magnitude between the brightest and the dimmest object.\n\nHow many objects are there in each viewing season (spring, summer, autumn, winter)? Before looking at the hint, see if you can approach this problem on your own!\n\nHint for Problem 3\n\nYou may want to define some variables as “counters” for the number of objects in each season, and then loop through every row of the dataset and add 1 to the corresponding counter if an object is in that season. Recall, you can use the sugar syntax a += 1 to add 1 to an exisiting variable (equivalent to a = a + 1).\n\nExercise Two: Getting More Practice\n\nThese problems are slightly more complicated, but you will be able to figure them out! Please join office hours or post in Slack if you have questions!\n\nCalculate the average distance of spiral galaxies (Type: 'Sp'), globular clusters (Type: 'Gc'), and open clusters (Type: 'Oc'). Which type of object is typically farther away? Does this make sense?\n\nHint for Problem 1\n\nYou can do this (at least) two ways! First, try using a condition to index the array. Your condition would be something that is checking the object types, and you can use that condition directly as the index to select only rows in the array where that condition is True. I think we have not technically gone over this yet, but see if you can try it out! Once you have the subset of the array that meets your condition, you can compute the average how we covered in lecture (as in exercise 1 problem 2).\n\nAnother way you could approach this problem (which you should be able to do with what we’ve covered in lecture) is by using a for loop to iterate over every row, and then using if statements to select based on type. How would you compute the average? Try to think creatively about how you can perform math on values (recall exercise 1 problem 3) iteratively in a loop. Maybe you will need to define two variables that you operate on each iteration of the loop, then do something to the two variables at the end after the loop finishes....\n\nHow many constellations are there in the dataset, and how many objects belong to each constellation?\n\nFirst, you need to find how many unique constellations exist in the dataset.\n\nThen, count how many Messier objects belong to each constellation.\n\nHint for Problem 2\n\nYou can try using a set to help find the unique constellations in the dataset. A set is a data structure that automatically removes duplicates, so it could be useful for counting how many distinct constellations there are. Most astronomers don’t often use set as a data structure, but it’s a very useful way to quickly get unique elements in a list or array!\n\nIf you feel comfortable, try using a set to collect the constellations and a dict (dictionary) to count the number of objects in each one (recall exercise 1 problem 3 for counting in loops). Remember, if you’re unsure about how to create or use a set, think about how a list works—sets work similarly but don’t allow duplicate values!\n\nHow many Messier objects are in the northern vs. southern sky? You could try to do this using the constellation information from the previous problem, but the hemisphere can more easily be determined by the declination. You may need to investigate and Google around to figure out how to tell if something is in the north or the south based on declination!\n\n","type":"content","url":"/lab3-2025#opening-the-dataset","position":3},{"hierarchy":{"lvl1":"Week 3 Lab: Program Flow, Logic, and Loops with the Messier Catalog!","lvl2":"Submission Requirements:"},"type":"lvl2","url":"/lab3-2025#submission-requirements","position":4},{"hierarchy":{"lvl1":"Week 3 Lab: Program Flow, Logic, and Loops with the Messier Catalog!","lvl2":"Submission Requirements:"},"content":"Submit your code as a .py file.\n\nInclude comments in your code explaining what each part does!!","type":"content","url":"/lab3-2025#submission-requirements","position":5},{"hierarchy":{"lvl1":"Course Topics by Week"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Course Topics by Week"},"content":"\nThis workshop series will focus on an introduction to the Python programming language in the context of physics and astrophysics applications. All research carried in these scientific fields requires the use of extensive programming, making it a bedrock skill of any scientist. In this seminar, we will start from square one, covering how to install and navigate the programming ecosystem such as the terminal/shell, before moving into how to create scientific programs in python to carry out calculations one might use in a research project. This workshop series is primarily intended for students with little to no exposure to coding or astronomy research. After taking this series, students should be prepared to tackle programming-based courses (e.g., ASTR 255/330) as well as feel comfortable applying to summer research positions.\n\nThis series meets twice a week in the afternoon (M/W 5-6). Monday sessions will have (interactive) lectures in which a new programming concept is introduced. Wednesday is a “lab” in which students will work on a weekly assignment targeting those concepts. We expect most students to finish the weekly assignment during the Wednesday session, but they are due the following Tuesday, so time can be taken outside of the seminar if needed.\n\nSignups for 2025 are now closed. Stay tuned for next year’s workshop!","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Course Topics by Week"},"type":"lvl1","url":"/#course-topics-by-week","position":2},{"hierarchy":{"lvl1":"Course Topics by Week"},"content":"Week 1 (Jan 25):\n\nUNIX, filesystems, environments and the Python ecosystem\n\nWeek 2 (Feb 10):\n\nPure Python programming, calculations, variables, datatypes and scripts\n\nWeek 3 (Feb 17):\n\nReview of Datatypes\n\nIntroduction to libraries\n\nnumpy and numpy arrays\n\nControl flow, loops, program logic, and an introduction to libraries\n\nWeek 4 (Feb 24):\n\nFunctions and functional programming\n\nIntroduction to ipython notebooks (jupyter)\n\nWeek 5 (Feb 26):\n\nVectorization and program efficiency\n\nFinal project introductions\n\nWeek 6 (March 4):\n\nWorking with astrophysical datasets (loading, analyzing, fitting, visualizing)\n\nSpring Break\n\nWeek 7 (March 25):\n\nIntroduction to Object Oriented Programming\n\nWeek 8 (April 1):\n\nIntroduction to github and version control + Bonus Content\n\nWeek 9 (April 8):\n\nFinal presentations\n\nFor a more detailed topic list, \n\nclick here","type":"content","url":"/#course-topics-by-week","position":3},{"hierarchy":{"lvl1":"Course Topics"},"type":"lvl1","url":"/topiclist","position":0},{"hierarchy":{"lvl1":"Course Topics"},"content":"UNIX, Filesystems, Environments and the Python Ecosystem\n\nIn this module we will familiarize students with the command line interface of computer operating systems, teach common unix commands, and discuss the installation of environments with Python, and where that is situated in the broader coding ecosystem.\n\nDiscussion of the differences between CS and DS/astronomy analysis\n\nSlides: \n\nhttps://​shorturl​.at​/hXcuT\n\nPure Python Programming, Calculations, Variables, Datatypes and Scripts\n\nIn this module, we introduce the basic python syntax, including variable declaration, basic mathematical operations, and the built-in datatypes (+numpy). We will transition from the iPython interpreter to standalone python scripts.3/\n\nIntroduction to Imports, Libraries, and numpy\n\nSlides: \n\nhttps://​shorturl​.at​/FNH0e\n\nControl flow, Loops, Program Logic, and an introduction to Libraries (astropy+matplotlib)\n\nIn this module we will first expand the set of applications by discussing package imports (beyond numpy), including matplotlib and astropy. We will then use relevant examples from these packages to teach program logic and control flow (if/else, try/except) and looping (for/while).\n\nWe will also take time here to discuss the parsing of error messages and how to debug errors in code.\n\n\n\nhttps://​docs​.google​.com​/presentation​/d​/11GgGeJfpOVJTTJ2fstbBm3ZPgCiY1AGJtCdW​-8BV55Y​/edit​?usp​=​sharing\n4. Functions and Functional Programming, Notebooks\n\nUsing examples from astropy+matplotlib+numpy, we will introduce the creation of user-defined functions in Python, their benefits, and best practices for documentation, including type annotations.\n\nAt this point, we will introduce the concept of jupyter notebooks, how they differ from standard scripts, and common pitfalls. We will provide a framework for development in notebooks by which functions are created and tested and then moved to a python module for import and use.\n\nVectorization, Program Efficiency, and Final Project Introductions\n\nIn this module we will discuss common programming pitfalls that lead to inefficient (slow) code, and we will formally introduce several methods to write code that will run as quickly as possible.\n\nWe will also introduce the final projects and get students thinking about ideas.\n\nWorking with Astrophysical Datasets (Loading, Analyzing, Fitting, Visualizing)\n\nIn this module, we will discuss several different libraries (including pandas) in the context of loading and working with more complex astronomical data (beyond individual fits images or simple two column tables) and different file types (csv, fits, hdf5, json). Additionally, retrieving data from online servers and catalogs (e.g., astroquery and sql).\n\nWe will discuss real statistical analyses one would apply to these data, and demonstrate several ways of carrying out model fits (e.g., with polyfit, spline fits, chi^2 grid searches, or mcmc).\n\nFinally, we will touch on more advanced plotting techniques for “publication” plots and figures which capture rich datasets.\n\nSpring Break (end of regular seminar content/assignments)\n\nIntroduction to Object Oriented Programming\n\nWe return to introductory discussions of objects in python and the OOP paradigm of creating objects with methods and attributes. We will show how to create simple classes that may be useful to students.\nNote there is no explicit lab for this; students are working on their final projects in class.\n\nIntroduction to Github and Version Control + Bonus Content\n\nWe will introduce the students to the basic use of github for version control. This will in turn prepare them to upload their final projects to github.\n\nWe have several “Bonus Content” Topics that we will allow the students to choose from during these last few weeks while the focus is on their final projects. There are no “regular” assignments for these weeks. Topics include:\n\nHTML/CSS and building a personal website\n\nLaTeX typesettings (for papers or homework)\n\nMore OOP discussion\n\nFinal Project Presentations\n\nFinally, we invite the students to present their final project demonstrations to the class. These projects represent several weeks of coding effort. Students are encouraged to choose any topic that interests them; we have had projects spanning the range from implementing a game like chess or battleship, to astronomy themed projects such as writing a simple integrator or simulating galaxy collisions. We will (potentially) be inviting the department at large to attend these presentations.","type":"content","url":"/topiclist","position":1}]}