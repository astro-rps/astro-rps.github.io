{"version":"1","records":[{"hierarchy":{"lvl1":"Welcome to the Astro Research Preparation Series!"},"type":"lvl1","url":"/intro","position":0},{"hierarchy":{"lvl1":"Welcome to the Astro Research Preparation Series!"},"content":"","type":"content","url":"/intro","position":1},{"hierarchy":{"lvl1":"Welcome to the Astro Research Preparation Series!","lvl2":"Lecture 1: UNIX, Filesystems, Environments, and the Python Ecosystem"},"type":"lvl2","url":"/intro#lecture-1-unix-filesystems-environments-and-the-python-ecosystem","position":2},{"hierarchy":{"lvl1":"Welcome to the Astro Research Preparation Series!","lvl2":"Lecture 1: UNIX, Filesystems, Environments, and the Python Ecosystem"},"content":"\n\n","type":"content","url":"/intro#lecture-1-unix-filesystems-environments-and-the-python-ecosystem","position":3},{"hierarchy":{"lvl1":"Welcome to the Astro Research Preparation Series!","lvl3":"Preface: Some things to keep in mind over the next nine weeks","lvl2":"Lecture 1: UNIX, Filesystems, Environments, and the Python Ecosystem"},"type":"lvl3","url":"/intro#preface-some-things-to-keep-in-mind-over-the-next-nine-weeks","position":4},{"hierarchy":{"lvl1":"Welcome to the Astro Research Preparation Series!","lvl3":"Preface: Some things to keep in mind over the next nine weeks","lvl2":"Lecture 1: UNIX, Filesystems, Environments, and the Python Ecosystem"},"content":"\n\nCoding is tough!\n\nLearning how to code is like learning a new language. It takes a long time to become comfortable, and the more you practice coding the easier it gets!\n\nWe are a community\n\nWe want this to be a space where we all feel comfortable speaking up, asking questions, and sharing ideas. All of the instructors learned from each other while preparing for this series (because, as per point 1, coding is tough), and we want that same spirit of community learning to be upheld in this space!\n\nWe are learning data science\n\nComputer science is a broader discipline that encompasses the study of algorithms, software engineering, operating systems, and more, while data science is focused on extracting insights from data (observational or simulated) using a combination of computer science, statistics, and domain-specific knowledge.\n\nToday, we are not doing Python! We will start with Python next week!\n\n","type":"content","url":"/intro#preface-some-things-to-keep-in-mind-over-the-next-nine-weeks","position":5},{"hierarchy":{"lvl1":"Welcome to the Astro Research Preparation Series!","lvl3":"Lesson Agenda","lvl2":"Lecture 1: UNIX, Filesystems, Environments, and the Python Ecosystem"},"type":"lvl3","url":"/intro#lesson-agenda","position":6},{"hierarchy":{"lvl1":"Welcome to the Astro Research Preparation Series!","lvl3":"Lesson Agenda","lvl2":"Lecture 1: UNIX, Filesystems, Environments, and the Python Ecosystem"},"content":"Intro + Preface: Done!\n\nFilesystems, UNIX, and Terminal\n\nQuestion Break\n\nInstalling Python + Virtual Environments","type":"content","url":"/intro#lesson-agenda","position":7},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data"},"type":"lvl1","url":"/unix","position":0},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data"},"content":"","type":"content","url":"/unix","position":1},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"What is a Filesystem?"},"type":"lvl3","url":"/unix#what-is-a-filesystem","position":2},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"What is a Filesystem?"},"content":"A filesystem is a way of organizing and storing data on a computer. It provides a structure for how data is stored and accessed. In the context of your computer, think of it as a file cabinet where you organize and store your files. Each file is stored in a specific location known as a directory or folder.\n\n","type":"content","url":"/unix#what-is-a-filesystem","position":3},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Directories and Folders","lvl3":"What is a Filesystem?"},"type":"lvl4","url":"/unix#directories-and-folders","position":4},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Directories and Folders","lvl3":"What is a Filesystem?"},"content":"On macOS, you might be familiar with the Finder application, which allows you to navigate through directories and see the contents of your computer’s filesystem in a graphical way. Directories, also known as folders, are containers that hold files or other directories.\n\nIn the example above, “Documents” is a directory that can contain multiple files. Understanding the concept of directories is crucial for organizing and managing your data, especially in research.\n\nFinder is not enough\n\nIn research, you eventually find that simply using user friendly interfaces like Finder to navigate through your filesystems will not be enough. There are many reasons we might need something more that will be explained throughout this tutorial! To give one example, sometimes applications will need to be installed from command line rather than having an easy installer for you to use.\n\n","type":"content","url":"/unix#directories-and-folders","position":5},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Enter: UNIX and Terminal"},"type":"lvl3","url":"/unix#enter-unix-and-terminal","position":6},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Enter: UNIX and Terminal"},"content":"UNIX is a powerful and versatile operating system that has been widely used in scientific computing, including astronomy and data science. It provides a command-line interface (CLI; also called the shell or the terminal) for interacting with the computer’s operating system. While modern versions of UNIX, such as Linux, macOS, and others, have evolved, they still retain the core principles and commands that originated with the original UNIX system.\n\nThe terminal is a text-based interface that allows users to interact with their computer’s operating system by typing commands. Unlike graphical user interfaces (GUIs) like Finder, which use visual elements like windows and buttons, the terminal relies on text commands.\n\nA note on terminology:\n\nOperating Systems: UNIX, Linux, macOS, Windows, Debian\n\nCLIs: Command line, terminal, shell (specific CLI)\n\nShell Languages: bash, zsh\n\n","type":"content","url":"/unix#enter-unix-and-terminal","position":7},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Key Components of the Terminal:"},"type":"lvl3","url":"/unix#key-components-of-the-terminal","position":8},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Key Components of the Terminal:"},"content":"Prompt: The prompt displays information about the system’s current state and awaits your command.\n\nCommand Line: This is where you input commands. You type a command and press Enter to execute it.\n\nOutput: After executing a command, the terminal provides output, displaying information or responses from the system.\n\nIn practice, your default mac terminal might look something like this:\n\n\n\nNote\n\nYou can also customize your terminal display to look nicer! I’m happy to help provide some tips and tricks on customizing your terminal at a later time, but you should also try it out for yourself!\n\n","type":"content","url":"/unix#key-components-of-the-terminal","position":9},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Anatomy of a UNIX Command:"},"type":"lvl3","url":"/unix#anatomy-of-a-unix-command","position":10},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Anatomy of a UNIX Command:"},"content":"Understanding the anatomy of a UNIX command is crucial for effectively using the command line. Let’s break down the key components: command, options/flags, and arguments.\n\nA UNIX command typically follows the structure:command [options/flags] [arguments]\n\nCommand:\n\nThe primary action you want the computer to perform.\n\nExamples: ls, cd, cp, mv, echo, etc.\n\nOptions/Flags:\n\nFlags modify the behavior of the command.\n\nUsually preceded by a hyphen (-) or double hyphen (--).\n\nExamples: -l, -a, --verbose, --force, etc.\n\nArguments:\n\nThe entities upon which the command acts.\n\nCan be file names, directories, strings, etc.\n\nExamples: file.txt, directory/, string, etc.\n\n","type":"content","url":"/unix#anatomy-of-a-unix-command","position":11},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Example Commands:","lvl3":"Anatomy of a UNIX Command:"},"type":"lvl4","url":"/unix#example-commands","position":12},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Example Commands:","lvl3":"Anatomy of a UNIX Command:"},"content":"Basic Command:ls\n\nCommand: ls\n\nOptions/Flags: None\n\nArguments: None\n\nCommand with Options:ls -l\n\nCommand: ls\n\nOptions/Flags: -l\n\nArguments: None\n\nCommand with Arguments:cp file.txt backup/\n\nCommand: cp\n\nOptions/Flags: None\n\nArguments: file.txt, backup/\n\n","type":"content","url":"/unix#example-commands","position":13},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Common UNIX Commands"},"type":"lvl3","url":"/unix#common-unix-commands","position":14},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Common UNIX Commands"},"content":"","type":"content","url":"/unix#common-unix-commands","position":15},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"1. pwd - Print Working Directory","lvl3":"Common UNIX Commands"},"type":"lvl4","url":"/unix#id-1-pwd-print-working-directory","position":16},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"1. pwd - Print Working Directory","lvl3":"Common UNIX Commands"},"content":"The pwd command is used to print the current working directory, which is the directory you are currently in within the file system.pwd\n\nThis command will display the full path to the current directory.\n\n","type":"content","url":"/unix#id-1-pwd-print-working-directory","position":17},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"2. ls - List Files","lvl3":"Common UNIX Commands"},"type":"lvl4","url":"/unix#id-2-ls-list-files","position":18},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"2. ls - List Files","lvl3":"Common UNIX Commands"},"content":"The ls command is used to list the files and directories in the current directory.ls\n\nThis command provides a simple listing of the files and directories in the current location.\n\n","type":"content","url":"/unix#id-2-ls-list-files","position":19},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"3. cd - Change Directory","lvl3":"Common UNIX Commands"},"type":"lvl4","url":"/unix#id-3-cd-change-directory","position":20},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"3. cd - Change Directory","lvl3":"Common UNIX Commands"},"content":"The cd command is used to change the current working directory. You can move to a different directory by specifying the path.cd /path/to/directory\n\nUse cd .. to move up one level in the directory hierarchy.\n\nExercise One: Using Terminal\n\nIn your shell/terminal (Terminal on Mac, Ubuntu on WSL), try\n\ncd .\n\ncd ..\n\ncd ...\n\nWhat do you think each of these do (without looking it up)? Now try\n\nls -l\n\nls -a\n\nWhat do you think these are doing?\n\nUnderstanding and practicing these basic commands will give you the foundation to navigate and interact with the file system using the UNIX command line. As we progress in the workshop, we’ll explore more advanced commands and concepts.\n\n","type":"content","url":"/unix#id-3-cd-change-directory","position":21},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl2":"Why are we doing this?"},"type":"lvl2","url":"/unix#why-are-we-doing-this","position":22},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl2":"Why are we doing this?"},"content":"Open Question\n\nNow, that you have seen a bit of what UNIX + terminal can do, can you think of any reasons why understanding how to use these tools is useful for astronomy research?\n\n","type":"content","url":"/unix#why-are-we-doing-this","position":23},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"1. Organizing Data","lvl2":"Why are we doing this?"},"type":"lvl4","url":"/unix#id-1-organizing-data","position":24},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"1. Organizing Data","lvl2":"Why are we doing this?"},"content":"When you conduct research, you often work with large datasets and various files. Knowing how to navigate through directories using the command line is essential. Let’s say you have to migrate a bunch of data files into a different location on your computer. You can use the following commands:\n# Create a subdirectory to organize the files\nmkdir data_files\n\n# Move all files with a specific extension (e.g., .txt) into the subdirectory\nmv *.txt data_files/\n\n\nThe mkdir data_files command creates a new subdirectory named “data_files” in the current directory. Then the mv *.txt data_files/ command moves all files with the extension “.txt” into the “data_files” subdirectory. There are lots of different ways you can change these commands to move your data in different ways:\n\nyou can customize the file extension based on your specific data files\n\nyou can specify arbitrary folders to move files between rather than using the current directory\n\nyou could use keywords in the filenames to select files rather than their extensions\n\nUNIX commands are incredibly flexible and can become incredibly complicated. There will almost always be a solution your specific problem!\n\n","type":"content","url":"/unix#id-1-organizing-data","position":25},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"2. Navigating to Data in your Code","lvl2":"Why are we doing this?"},"type":"lvl4","url":"/unix#id-2-navigating-to-data-in-your-code","position":26},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"2. Navigating to Data in your Code","lvl2":"Why are we doing this?"},"content":"Understanding filesystems becomes crucial when writing code. Your code will not know where your data lives unless you tell it. If your code throws an error like “File not found” or “No such file or directory,” it’s often because the file is not in the specified directory (or there’s a typo in the file name).\n\nYou will see examples of specifying the path to the data once we start working with Python in the coming weeks!\n\n","type":"content","url":"/unix#id-2-navigating-to-data-in-your-code","position":27},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"3. Executing Code, Managing Dependencies, Version Control, and More!","lvl2":"Why are we doing this?"},"type":"lvl4","url":"/unix#id-3-executing-code-managing-dependencies-version-control-and-more","position":28},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"3. Executing Code, Managing Dependencies, Version Control, and More!","lvl2":"Why are we doing this?"},"content":"Understanding UNIX + Filesystems is important for many many more aspects of research beyond data management! We can’t get into all of these now, but as a preview:\n\nWhen we want to ``execute\" python code, we can do it from command line\n\nWhen we want to remotely operate another computer (for instance, at a telescope or a supercomputer cluster)\n\nWhen we want to manage code installations + packages\n\n","type":"content","url":"/unix#id-3-executing-code-managing-dependencies-version-control-and-more","position":29},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl2":"Text Editors: Vim and Nano"},"type":"lvl2","url":"/unix#text-editors-vim-and-nano","position":30},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl2":"Text Editors: Vim and Nano"},"content":"\n\n","type":"content","url":"/unix#text-editors-vim-and-nano","position":31},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Vim","lvl2":"Text Editors: Vim and Nano"},"type":"lvl3","url":"/unix#vim","position":32},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Vim","lvl2":"Text Editors: Vim and Nano"},"content":"Vim (Vi Improved) is a powerful and highly configurable text editor that is widely used in the programming community. It operates in different modes, allowing users to navigate, edit, and manipulate text efficiently. Vim has a steeper learning curve, but its super versatile and its my favorite.","type":"content","url":"/unix#vim","position":33},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Basic Vim Commands","lvl3":"Vim","lvl2":"Text Editors: Vim and Nano"},"type":"lvl4","url":"/unix#basic-vim-commands","position":34},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Basic Vim Commands","lvl3":"Vim","lvl2":"Text Editors: Vim and Nano"},"content":"Normal Mode: Used for navigating and manipulating text. You start in normal mode, and can press Esc to return to normal mode.\n\nh, j, k, l, or arrow keys: Move left, down, up, and right, respectively.\n\ndd: Delete a line.\n\nyy: Copy a line.\n\np: Paste the copied or deleted text.\n\nInsert Mode: Used for inserting or editing text. Press i to enter Insert Mode.\n\nYou can type to insert your desired text.\n\nVisual Mode Used for selecting text. Press v to enter Visual Mode.\n\nYou can select blocks of text (to copy/cut/paste different amounts of text)\n\nSpecial sub-modes: visual line mode (V) or visual block mode (<C-V>)\n\nCommand Mode: Used for executing commands. : to enter command mode.\n\n:w: Save changes.\n\n:q: Quit Vim (without changes) or :q! to force quit and delete unsaved changes\n\n:wq or :x or ZZ: Save and quit.\n\nYou can also do cool things like find and replace in this mode!\n\n","type":"content","url":"/unix#basic-vim-commands","position":35},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Nano","lvl2":"Text Editors: Vim and Nano"},"type":"lvl3","url":"/unix#nano","position":36},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl3":"Nano","lvl2":"Text Editors: Vim and Nano"},"content":"Nano is a straightforward and user-friendly text editor that is beginner-friendly. It provides a simple interface for editing text files and is particularly suitable for quick edits or when a full-featured editor like Vim might be overwhelming.","type":"content","url":"/unix#nano","position":37},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Basic Nano Commands","lvl3":"Nano","lvl2":"Text Editors: Vim and Nano"},"type":"lvl4","url":"/unix#basic-nano-commands","position":38},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Basic Nano Commands","lvl3":"Nano","lvl2":"Text Editors: Vim and Nano"},"content":"Saving Changes:\n\nPress Ctrl + O to write changes.\n\nPress Enter to confirm the file name.\n\nExiting Nano:\n\nPress Ctrl + X to exit Nano.\n\nEditing Text:\n\nUse arrow keys to navigate.\n\nUse Backspace to delete characters.\n\nPress Ctrl + K to cut a line.\n\nPress Ctrl + U to paste the cut line.\n\n","type":"content","url":"/unix#basic-nano-commands","position":39},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Choosing an Editor","lvl3":"Nano","lvl2":"Text Editors: Vim and Nano"},"type":"lvl4","url":"/unix#choosing-an-editor","position":40},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Choosing an Editor","lvl3":"Nano","lvl2":"Text Editors: Vim and Nano"},"content":"The choice between Vim and Nano often depends on personal preference and familiarity. Vim’s power lies in its extensive features, while Nano excels in simplicity and ease of use. Both editors offer efficient ways to manipulate and edit text, and the choice ultimately depends on your comfort level and requirements.\n\n","type":"content","url":"/unix#choosing-an-editor","position":41},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl2":"Piping UNIX Commands"},"type":"lvl2","url":"/unix#piping-unix-commands","position":42},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl2":"Piping UNIX Commands"},"content":"Piping involves directing the output of one command as input to another command. The symbol for piping is |. This allows you to chain commands together, creating powerful and flexible workflows.\n\n","type":"content","url":"/unix#piping-unix-commands","position":43},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Example 1: Basic Pipe between Two Commands","lvl2":"Piping UNIX Commands"},"type":"lvl4","url":"/unix#example-1-basic-pipe-between-two-commands","position":44},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Example 1: Basic Pipe between Two Commands","lvl2":"Piping UNIX Commands"},"content":"ls -l | grep \"txt\"\n\nThe ls -l command lists files in long format.\n\nThe output of ls -l is piped (|) to the grep \"txt\" command.\n\ngrep \"txt\" searches for lines containing the string “txt” in the output.\n\nOpen Question\n\nIs there any unexpected behavior with this command? How could it get you to the wrong answer?\n\n","type":"content","url":"/unix#example-1-basic-pipe-between-two-commands","position":45},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Example 2: Saving Output using Piping","lvl2":"Piping UNIX Commands"},"type":"lvl4","url":"/unix#example-2-saving-output-using-piping","position":46},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl4":"Example 2: Saving Output using Piping","lvl2":"Piping UNIX Commands"},"content":"You can also pipe the output of a UNIX command into a text file to save it. Here’s an example:# List all files in the current directory and save the output to a text file\nls -l > file_list.txt\n\nAgain, the ls -l command lists files in long format.\n\nThe > symbol redirects the output of the command to a file.\n\nfile_list.txt is the name of the text file where the output will be saved.\n\nAfter executing this command, the detailed listing of files in the current directory will be saved in the file_list.txt file.\n\nExercise Two: Experimenting with Commands\n\nIn your shell/terminal (Terminal on Mac, Ubuntu on WSL), try\n\nls | wc\n\nls -l | wc\n\nls | wc -l\n\nWhat do you think each of these do?\n\n","type":"content","url":"/unix#example-2-saving-output-using-piping","position":47},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl2":"And that’s it!"},"type":"lvl2","url":"/unix#and-thats-it","position":48},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl2":"And that’s it!"},"content":"\n\n","type":"content","url":"/unix#and-thats-it","position":49},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl2":"Appendix: Useful UNIX commands for your reference"},"type":"lvl2","url":"/unix#appendix-useful-unix-commands-for-your-reference","position":50},{"hierarchy":{"lvl1":"Introduction to UNIX and Filesystems: Navigating and Managing Data","lvl2":"Appendix: Useful UNIX commands for your reference"},"content":"Here’s a list of some important UNIX commands that can serve as a quick reference:\n\npwd: Print the current working directory.\n\nls: List files and directories in the current directory.\n\ncd: Change the current working directory.\n\ncd /path/to/directory: Change to the specified directory.\n\ncd ..: Move up one level in the directory hierarchy.\n\nmkdir: Create a new directory.\n\nmkdir new_directory: Create a directory named “new_directory”.\n\ncp: Copy files or directories.\n\ncp file.txt /path/to/destination: Copy “file.txt” to the specified destination.\n\nmv: Move or rename files or directories.\n\nmv old_name new_name: Rename a file or directory.\n\nmv file.txt /path/to/destination: Move “file.txt” to the specified destination.\n\nrm: Remove files or directories.\n\nrm file.txt: Remove “file.txt”.\n\nrm -r directory: Remove a directory and its contents.\n\ncat: Display the content of a file.\n\ncat file.txt: Display the content of “file.txt”.\n\necho: Print text to the terminal.\n\necho \"Hello, World!\": Print the text “Hello, World!”.\n\nman: Display the manual or help for a command.\n\nman ls: Show the manual for the ls command.\n\nchmod: Change file permissions.\n\nchmod +x script.sh: Add execute permission to a script.\n\ngrep: Search for a pattern in files.\n\ngrep pattern file.txt: Search for “pattern” in “file.txt”.\n\nps: Display information about running processes.\n\nps aux: Show detailed information about all processes.\n\nkill: Terminate a process.\n\nkill process_id: Terminate the process with the specified ID.\n\nnano or vim: Text editors for creating and editing files.\n\nnano filename.txt: Open “filename.txt” in the Nano text editor.\n\nThese commands cover basic file and directory manipulation, text file viewing, process management, and more.","type":"content","url":"/unix#appendix-useful-unix-commands-for-your-reference","position":51},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments"},"type":"lvl1","url":"/environments","position":0},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments"},"content":"Now that we have a foundational understanding of UNIX and filesystems, let’s explore the Python programming language and its ecosystem. Python is widely used in scientific computing, and understanding its installation, package management, and the use of virtual environments is crucial.\n\n","type":"content","url":"/environments","position":1},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments","lvl2":"Python Installation and Package Management"},"type":"lvl2","url":"/environments#python-installation-and-package-management","position":2},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments","lvl2":"Python Installation and Package Management"},"content":"Python can be installed in different ways on your computer. Usually, when we use python we also use external libraries. An external library is basically a collection of useful code written by someone else that you can acess without having to rewrite it yourself (you will learn more about these over the next few weeks). Python relies on package managers to install, update, and manage external libraries. The two primary package managers are:\n\npip: The default Python package installer.\n\nExample: pip install package_name\n\nConda: A cross-language package manager that simplifies dependency management.\n\nExample: conda install package_name\n\nUnderstanding how to use these package managers is essential for incorporating external libraries into your Python projects. You might also encounter homebrew or MacPorts. These are two other popular package managers, but they are not as common in astronomy.\n\n","type":"content","url":"/environments#python-installation-and-package-management","position":3},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments","lvl3":"Using Conda as a Package Manager","lvl2":"Python Installation and Package Management"},"type":"lvl3","url":"/environments#using-conda-as-a-package-manager","position":4},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments","lvl3":"Using Conda as a Package Manager","lvl2":"Python Installation and Package Management"},"content":"When we use conda, we have the option of using different distributions:\n\nMiniconda: A minimal installer for the Conda package manager, which only includes Conda and Python.\n\nAnaconda: A distribution that includes Python, Conda, and a large array of pre installed packages.\n\nOne of the features of conda (as opposed to pip) is that we can create virtual environments. You should all now have miniconda installed, so we can start making a virtual environment!\n\n","type":"content","url":"/environments#using-conda-as-a-package-manager","position":5},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments","lvl2":"Python Virtual Environments"},"type":"lvl2","url":"/environments#python-virtual-environments","position":6},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments","lvl2":"Python Virtual Environments"},"content":"","type":"content","url":"/environments#python-virtual-environments","position":7},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments","lvl3":"What is a Virtual Environment?","lvl2":"Python Virtual Environments"},"type":"lvl3","url":"/environments#what-is-a-virtual-environment","position":8},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments","lvl3":"What is a Virtual Environment?","lvl2":"Python Virtual Environments"},"content":"A virtual environment in Python is a self-contained directory that encapsulates a specific Python interpreter along with its associated libraries and scripts. It allows you to create isolated environments for different projects, each with its own set of dependencies, without affecting the system-wide Python installation.","type":"content","url":"/environments#what-is-a-virtual-environment","position":9},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments","lvl3":"Why Use Virtual Environments?","lvl2":"Python Virtual Environments"},"type":"lvl3","url":"/environments#why-use-virtual-environments","position":10},{"hierarchy":{"lvl1":"The Python Ecosystem and Virtual Environments","lvl3":"Why Use Virtual Environments?","lvl2":"Python Virtual Environments"},"content":"When working on multiple projects, each with its own set of dependencies, managing packages can become challenging. Virtual environments provide an isolated space for each project, allowing you to avoid conflicts between different project requirements. Code in pacakges and libraries can often change with new releases and versions, so it’s important to work in environments to keep track of your Python version and the versions of the external packages you use.\n\nNote\n\nIt is always a good idea to create a new environment when you are starting a new research project, installing a particularly complex code that has a lot of dependencies, or developing your own piece of software.\n\nExercise One: Make an Environment\n\nIn your shell/terminal, writeconda create -n astro-rps python=3.9 numpy scipy matplotlib astropy pandas jupyterlab ipython ipykernel nb_conda_kernels\n\nThis line creates as conda virtual environment called astro-rps. When you run this, you will eventually get a prompt asking for a Y/n input; type Y and hit enter.\n\nWhat this commmand does is create a new environment with the name you give it. We’ve specifically told it to use Python 3.11. We’ve also given it a list of packages that can be installed via conda; I chose these because they are universally useful in astronomy and we will need them anyway. You can specify their versions here, as we did for python, but for now, we just want the latest versions.\n\nExercise Two: Activate Your Environment\n\nOnce your environment is created, you’ll see instructions for “activating” it. Follow them, e.g.,conda activate astro-rps\n\nOnce inside the environment, you should see its name on the left hand side of your terminal prompt, in parenthesis. Lets install a few more things, but this time, using pip, the standard python package installerpip install tqdm \npip install astroquery\n\nInstalling Individual Pacakges: Conda vs. Pip\n\nWhen do we install a package using conda, and when do we use pip? This is a bit messy, but in general, I suggest checking first if a conda version of the package is available. If it is, try installing via conda first. If not, or if that fails, then fall back on using pip (Inside your environment of course!). Using pip inside an environment will still mean you are only installing to that environment, but some of conda’s ways of measuring package dependencies and compatibility don’t extend to things installed with pip. Generally, we create environments with the “big things” installed with conda (as above), then install smaller, or pip-only things, inside with pip.","type":"content","url":"/environments#why-use-virtual-environments","position":11},{"hierarchy":{"lvl1":"First Python Codes"},"type":"lvl1","url":"/first-python-codes","position":0},{"hierarchy":{"lvl1":"First Python Codes"},"content":"Last week, we focused on how to navigate the Terminal, and set up our environments from which we can run Python. This week, we’re going to actually run Python. By the end of this part of today’s lesson, you will be able to...\n\nRun Python interactively through the Terminal\n\nCreate, edit, and run .py “scripts”: saveable, reproducible Python codes\n\nUnderstand and demonstrate the basic use of the print() function\n\nWrite and run your own classic “Hello World!” Python script\n\nWrite a multi-line Python script and understand basic program layout\n\n","type":"content","url":"/first-python-codes","position":1},{"hierarchy":{"lvl1":"First Python Codes","lvl2":"A Quick Reminder"},"type":"lvl2","url":"/first-python-codes#a-quick-reminder","position":2},{"hierarchy":{"lvl1":"First Python Codes","lvl2":"A Quick Reminder"},"content":"\n\nLast week, we set up conda environments that we’ll be using for the whole Astro-RPS series. Before we move forward, you’ll want to move into your “working directory” where you’ve been working on everything up till now (reminder: you can use cd [dirname] to navigate to your working directory from within the terminal). Once you’ve done that, activate the astro-rps environment:conda activate astro-rps\n\nNow, you can activate Python in the same terminal by simply typing:\n\npython\n\nor equivalently,\n\npython3.8\n\nIf things work properly, you should see a message that includes a few details about the Python version you are running, your operating system, etc. If you do, you should see a blinking cursor ready for you to type code in, often preceded by a >>>. From here, we should already be able to do some basic calculations.\n\nExercise One: Basic Mathematical Operations\n\nIn your shell/terminal where you have started up Python, try adding two numbers as below:10 + 2\n\n(hit enter when you’re done typing). This should return a single number. Then, tryprint(10+2)\n\nagain, hit enter. Is the output the same, or different? What happens when you swap out the + with “-”, then “/”, then “*”. What do each of these return?\n\nLastly, try:print(10 / 0)\n\nWhat happens?\n\nNow, in the same terminal, typeexit()\n\nand hit enter. Once you’ve done so, congrats! You’ve started, written, completed, and quit your first Python session.\n\nFrom here on, we actually will not recommend you use just “python” and instead recommend:   ipython\n\nThe differences are mostly unimportant, but it has some conveniences (like colored text for different keywords) that make it nicer to use.\n\nRunning Python Interactively in the Terminal vs. “Scripting”\n\nWhen we run Python interactively like we did above, then quit, none of the operations and outputs are saved. While you can sometimes use the up arrowkey to see recent commands and perhaps re-run them that way manually, this this obviously isn’t the way most codes are written: we normally care a lot about saving our work so that we can expand upon it later and re-run. So, in short, don’t do work in interactive Python sessions that you want to preserve later.\n\nWhat do we instead? We create scripts. This is just a fancy way of saying “codes that we save in files”. In Python, these have the file extension .py, i.e., you might call your script “code.py” (or hopefully something more descriptive).\n\nTo create a script, first exit Python. This should you leave in a normal bash shell, from which you can type\n\ntouch first_script.py\n\nThe command “touch” simply creates a basic text file with the name provided afterwards (here, first_script.py). We are now free to edit this file through whatever means we want: for now, open it up in whatever text editor you prefer (e.g., TextEdit, Notepad, Text Editor for Mac, Windows, and Linux respectively).\n\nNow, try adding print(\"Hello World!\")\n\ninto that file and save it. Then, open up a bash terminal (don’t type python) and typepython first_script.py\n\nfrom within the same directory where you saved the file. If you’re in the right place, your bash shell should print out the words Hello World. If you run into an error, check first that you’re in the right directory (and if not, use cd to get there).\n\n","type":"content","url":"/first-python-codes#a-quick-reminder","position":3},{"hierarchy":{"lvl1":"First Python Codes","lvl2":"Comments"},"type":"lvl2","url":"/first-python-codes#comments","position":4},{"hierarchy":{"lvl1":"First Python Codes","lvl2":"Comments"},"content":"\n\nWhat if we want to put something into the code that we don’t want to run? In that case, we can comment lines using the #. For our script above, we could add a description of what the code is doing as follows:\n\n # This is a program to print the words Hello World.\n print(\"Hello World!\") # this is the line that does the printing.\n\nAs can be seen, anything after the hashtag is completely ignored by Python.  This is true whether you’ve put the commented phrase on its own line or at the end of another line.\n\nThere’s not much more to comments than this! Broadly speaking, commenting is vital piece of making sure codes are understandable. We encourage you to include comments throughout your codes that indicate what important lines are doing. This will help avoid the situation where you log on a week later and totally lose the train of thought that you had the previous week (speaking from experience, we promise this really will happen).\n\n","type":"content","url":"/first-python-codes#comments","position":5},{"hierarchy":{"lvl1":"First Python Codes","lvl2":"Writing Multi-line Programs"},"type":"lvl2","url":"/first-python-codes#writing-multi-line-programs","position":6},{"hierarchy":{"lvl1":"First Python Codes","lvl2":"Writing Multi-line Programs"},"content":"\n\nWith the basics down, we can start to complexify. In Python, distinct commands are separated onto different lines. In most situations, Python is linear: lines are executed from the top to the bottom. To see this for a case when you want to print two different things, you can write the code:# This code prints a phrase and a number.\nprint(\"Hello World!\")\nprint(5+5)\n\nEach print statement has an implicit (but hidden) command at the end that tells it to move to the next line after printing, so you should find that this prints out each result on its own line. If you don’t want that, one choice of syntax to avoid that is:\n\nprint(\"Hello World!\", 5+5)\n\nwhere all we’ve done is separate the things we want by commas. As we’ll later discuss, print() is what we call a function that can take any number of arguments (things inside the parantheses).\n\nDoes the spacing and layout of the script file matter?\n\nYes and no. In general, “vertical” spacing in Python does not matter - you can feel free to hit enter as many times between the lines in your .py file. The number of spaces within the middle of a line also doesn’t matter, so print(5 + 5) yields the same result as print(5        +      5). However, horizontal aligment does matter. Lines should generally all start at the same left-justification, unless you are working with if statements, loops, or creating your own functions (more on each of those later). Let’s try to write a very simple code to demonstrate this.\n\nExercise Two: Testing Python Spacing Rules\n\nIn your first_codes.py file, add a tab or some spaces before the start of the second line:print(\"Hello World!\")\n    print(5+5)\n\nWhen you try to run this script, you should find that “Hello World” does not print. Instead, you will get an IndentationError - telling you that Python expected the second line to be left-aligned with the first line. You might wonder: why does the first line not work, even if the error is on the second line?\n\nThe short answer is that Python does a quick check before running your code to see if there any obvious bugs. This procedure is not quite as robust as in some other programming languages, and it won’t catch things like DivideByZero errors, infinite loops, etc. However, it will raise an immediate error if it seems things like unusual spacing or undefined variables (more on the latter in the next notebook).  Thus, for the example above, the error is raised before the first line of code is actually run, breaking the program flow.\n\n","type":"content","url":"/first-python-codes#writing-multi-line-programs","position":7},{"hierarchy":{"lvl1":"First Python Codes","lvl2":"What if we want to store information between lines?"},"type":"lvl2","url":"/first-python-codes#what-if-we-want-to-store-information-between-lines","position":8},{"hierarchy":{"lvl1":"First Python Codes","lvl2":"What if we want to store information between lines?"},"content":"\n\nThus far, we’ve only done a very simple set of computations and immediately printed the result. What if we instead wanted to store the result of that calculation for later? In that case, we will want to define a variable. It’s best to see this by example:\n\nresult = 5 + 5 \nprint(result)\n\nHere, we have stored the result of the 5+5 . We could have named “result” anything we wanted - you’re free to choose the name (within certain rules - e.g., t can’t start with a number). In this context, the = sign acts as a so-called “assignment operator”: it takes whatever is on the righthand side and stores it in whatever we have called the variable on the lefthand side. It has nothing to do with equalities or truth/falsity.\n\nWe now have everything we need to write our first useful Python program.","type":"content","url":"/first-python-codes#what-if-we-want-to-store-information-between-lines","position":9},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes"},"type":"lvl1","url":"/variables-datatypes-2025","position":0},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes"},"content":"In the prior notebook, we introduced how to write more sophisticated multi-line codes using scripts. Here, we’re going to momentarily put scripting aside and focus on introducing some basic vocabulary that we will build on throughout the series. By the end of the day, you should be able to...\n\nDefine the most important variable types in Pythons (int, float, string, list)\n\nUse F-strings to refer to variables in printed strings\n\nUse basic indexing to access elements of a list\n\nWrite codes that take in inputs from the command line\n\nUnderstand the basic distinction between functions, objects, and variables\n\n","type":"content","url":"/variables-datatypes-2025","position":1},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl2":"Variables in Python"},"type":"lvl2","url":"/variables-datatypes-2025#variables-in-python","position":2},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl2":"Variables in Python"},"content":"\n\nIn the previous notebook, we restricted our consideration of variables to simple numerical variables that we could add, subtract, multiply etc. easily in Python. However, variables are a lot more flexible than that in Python. To illustrate this point, here are four different valid variable definitions:\n\n# define six different Python variables\nx = -6\nwidth = 7.0\nanimal_name = 'cat'\ndogs_are_friends = True \nlist_of_classes = ['french', 'galaxies', 'philosophy']\ndictionary1 = {'Name': 'Steve', 'Address': '219 Prospect Street', 'Office Number': 501}\n\nReminder: the ‘=’ sign in each line of the above is NOT a mathematical statement. A single equals sign is the assignment operator: it takes whatever is on the righthand side and stores it in the lefthand side. As before, we are free to print any of these, e.g.,print(list_of_classes)\n\nwhich largely just prints whatever was on the righthand side of our variable declaration.\n\nAs is clear from the above examples, there’s clearly a diversity in what can be stored in a Python variable. We call the different types of things that variables can be data types. All the data types have a unique name and a set of properties. To see their names, we can try:\n\nprint(type(width))\n\nExercise One: Deducing variable types in Python\n\nUsing a terminal session in Python or a script, find the data types for the remaining variables in the earlier cell.\n\nNow that we know how to check the type of a given variable, let’s dig into the properties of each type.\n\n","type":"content","url":"/variables-datatypes-2025#variables-in-python","position":3},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl3":"Integers","lvl2":"Variables in Python"},"type":"lvl3","url":"/variables-datatypes-2025#integers","position":4},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl3":"Integers","lvl2":"Variables in Python"},"content":"\n\nIntegers (int) for short are your run-of-the-mill counting numbers (.., -2, -1, 0, 1, 2.. etc). They obey all the basic arithmetic you expect:\n\na =  6\nb = -4 \nprint(a+b, a-b, a * b)\n\nIn each of these cases, adding/subtracting/multiplying two integers results in another integer. This is hopefully intuitive. But what about dividing two integers?\n\nc = 5\nd = 2\ne = c / d\n\nprint(e) ## print the result of the calculation above\n\nIf we now check the type of the result,\n\nprint(type(e))\n\nWe can see that it’s something else -- a float.\n\n","type":"content","url":"/variables-datatypes-2025#integers","position":5},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl3":"Floats","lvl2":"Variables in Python"},"type":"lvl3","url":"/variables-datatypes-2025#floats","position":6},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl3":"Floats","lvl2":"Variables in Python"},"content":"\n\nFloats, short for “floating point numbers,” are numbers with decimal places. As can be seen from the example above, Python automatically recognizes that it needs to use a float variable type to store the division of the variable c by the variable d. This is NOT the case in many other programming languages! In Java or C, for example, e would be an integer result equal to 2. Python is free to do this because it dynamically allocates memory to variable types, as opposed to pre-specifiying how much memory a variable needs.\n\nIf we want to specify that a number is a float, there are at least three equivalent ways of doing that:\n\nf1 = float(24)\nf2 = 24.\nf3 = 24.0\n\nprint(type(f1), type(f2), type(f3))\n\nIn the first line here, float() is a function that takes whatever is in the parantheses (the so-called argument) and converts it to a float.\n\nExercise Two: The Stefan-Boltzmann Law\n\nCreate a new code file called “SB.py”. Within SB.py, write the necessary code to calculate the Luminosity (L) of a star according to the Stefan-Boltzmann law,L = 4\\pi R^2 \\sigma T^4\n\nIn doing so, define a unique variable for each of L, pi, sigma, R, and T (where the latter are radius and temperature); don’t just put the computation in a print statement. Using pi = 3.14 and sigma = 5.67 * 10^{-8} \\rm \\ W/m^{2}/K^{4},\nwhat is the luminosity of a star with R = 7 * 10^8 meters and T = 5776 K? You can assume the units work out (and therefore you can ignore them in Python). Hint: use the ** to use powers in Python, e.g., 2 ** 3 will give you 8.\n\nPrint L and compare your value to the Solar luminosity, 3.8 * 10^{26} Watts. Is your value greater, less than, or equal to the Solar luminosity?\n\n","type":"content","url":"/variables-datatypes-2025#floats","position":7},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl3":"Strings","lvl2":"Variables in Python"},"type":"lvl3","url":"/variables-datatypes-2025#strings","position":8},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl3":"Strings","lvl2":"Variables in Python"},"content":"\n\nStrings are essentially just letters enclosed by pairs of quotes ’ '. Almost any common character can be included in a string, including things like spaces, and strings can be any length (including length 0). Some examples:\n\nanimal_name = 'cat'\nblank_string = ''\nnet_id = 'zzz56'\nprint(animal_name, blank_string, net_id)\n\nNote that both single and double quotes will both work - just be consistent.\n\nIf you want to check how many characters are in a string, you can use the len() function:print(len(animal_name))\n\nReferencing Variables within Strings\n\nOften, you will find yourself wanting to write programs where you compute a result and then describe it in the context of a sentence/phrase. In Python, we do this using what are called “F-strings”. They work like this:age = 22\nread_age = 19\n\nprint(f\"I am {age} years old\")\n\nYou can do this with any number of variables in your string:age = 22\nread_age = 19\nprint(f\"I am {age} years old and I learned to read at {read_age}\")\n\nNote that this is functionally equivalent to doingage = 22\nread_age = 19\nprint(\"I am\", age, \"years old and I learned to read at\", read_age)\n\npotentially up to some spacing differences.\n\nAnother property of strings is that they can be concatenated (added together) with the “+” operator. For example,string1 = 'hot'\nstring2 = 'dog'\nprint(string1 + string2)\n\nExercise Three: Exploring String Operations\n\nIn the above, we showed that strings can be concatenated with “+”. But what does “-” or “*” do? What happens if you do a string * a number?\n\nLastly, it is occasionally useful to note that you can force quantities to be strings by using the str() function. For example, acc = str(9.8)\nprint(type(acc))\n\n","type":"content","url":"/variables-datatypes-2025#strings","position":9},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl3":"Lists","lvl2":"Variables in Python"},"type":"lvl3","url":"/variables-datatypes-2025#lists","position":10},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl3":"Lists","lvl2":"Variables in Python"},"content":"\n\nLists are exactly what they sound like: they are lists of “stuff” in Python, enclosed by hard brackets [ ]; the items in the list are called elements. You can put anything within a list, including any other data type (and even lists..)\n\n# a list of elements with all the same data types:\nlist_of_animals = ['cat', 'dog', 'frog']\nprint(list_of_animals)\n\n# a list of elemetns with varied data types:\nrandom_stuff = ['8', True, 'frog', (8,7)]\nprint(random_stuff)\n\n# an empty list\nempty_list = []\nprint(empty_list)\n\nJust like we did for strings, we can find the length of a list as follows:list1 = ['a','b','c','d']\nlength = len(list1)\nprint(length)\n\nIf we have an existing list and want to add an element to the end, we can use the function .append():list1 = ['a','b','c','d']\nprint(list1, len(list1))\nlist1.append('e')\nprint(list1, len(list1)) # print again to see the effect of the change\n\nwhich might come in especially handy if you want to build up an empty list, e.g.,list_of_numbers = []\nlist_of_names.append('999-301-9191')\n\nWe can also do the same with remove():list_of_animals = ['cat','cat', 'dog', 'frog','cat']\nprint(list_of_animals)\nlist_of_animals.remove('cat')\nprint(list_of_animals)\n\n","type":"content","url":"/variables-datatypes-2025#lists","position":11},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl3":"List indexing","lvl2":"Variables in Python"},"type":"lvl3","url":"/variables-datatypes-2025#list-indexing","position":12},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl3":"List indexing","lvl2":"Variables in Python"},"content":"\n\nAn important property of lists is that they are (implictly) indexed: each element has an associated index that specifies its position. Importantly, these count up starting from 0 (not 1!!) and go up to the length of your list minus one.  For example,letters = ['a','b','c','d']\nprint(letters[0]) # return the first item in the list\nprint(letters[1]) # return the second item in the list\n\nIf you try to use an an index that is >= the length of the list, you will run into an error since that index doesn’t exist:letters = ['a','b','c','d']\nprint(letters[4]) # attempt to return the 5th element of a 4-element list; this will fail\n\nAnother useful index is -1, which will return the last element of the list:letters = ['a','b','c','d']\nprint(letters[-1]) # this will print 'd'\n\nIf we only want to print a subset of the list, you can use so-called list “slicing” with the colon (:). You can specify both the starting and ending index, as such:\n\nletters = ['a','b','c','d']\nprint(letters[1:3]) # this will print\n\nHere, only two elements are return because the : will not select the element with index equal to the number that comes after the colon.\n\nExercise Four: Practice accessing Specific Elements in a List\n\nDefine a list containing the first 7 powers of 2 (i.e., 2, 4, 8, etc).\n\nWhat is the index of the number 8 in your list?\n\nUsing list slicing, select the elements [8,16,32] and store them in a variable called middle_numbers\n\nWe can also use functions to compute summary statistics for lists comprised only of numbers, e.g.,grades = [71, 85, 81, 92, 97, 100, 67, 45]\nworst_grade = min(grades)\nbest_grade = max(grades)\n\nprint(f\"The worst grade on the test was {worst_grade} and the best grade was {best_grade}.\")\n\nExercise Five: Calculating Averages\n\nConsider the list of grades above. Using the sum() and len() functions, find the average of the reported grades.\n\n","type":"content","url":"/variables-datatypes-2025#list-indexing","position":13},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl2":"Booleans"},"type":"lvl2","url":"/variables-datatypes-2025#booleans","position":14},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl2":"Booleans"},"content":"\n\nBooleans are essentially binary truth values: True or False.\n\nis_physics_fun = False\ntoday_is_Monday = True\n\nThey can naturally arise when using (in)equality operators:\n\nprint(6 > 7)\nprint('cat' == 'cat') # double equal sign checks for equality; single equal sign is for assignment\nprint('cat' != 'cat')  # != is how we say \"not equal to\" in Python\n\nAs with any other type of variable, you could store the output of some operation as follows:\n\nresult = (7 > 6) # evaluate the inequality, and store a boolean in the variable called result\nprint(result)\n\nBooleans are very useful for controlling program flow. We’ll discuss this at length next week.\n\n","type":"content","url":"/variables-datatypes-2025#booleans","position":15},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl2":"Dictionaries"},"type":"lvl2","url":"/variables-datatypes-2025#dictionaries","position":16},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl2":"Dictionaries"},"content":"\n\nA more complicated -- but very useful -- data type in Python is the dictionary. It provides a structured way to store data that can be accessed with a “key” (roughly, a column name). For example,dictionary1 = {'Name': 'Steve', 'Address': '219 Prospect Street', 'Office Number': 501}\nprint(dictionary1['Name'])\n\nIn the event you need to access the list of fields, you can print dictionary1.keys().\n\n","type":"content","url":"/variables-datatypes-2025#dictionaries","position":17},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl2":"Aside: Taking Command-Line inputs during Python scripts"},"type":"lvl2","url":"/variables-datatypes-2025#aside-taking-command-line-inputs-during-python-scripts","position":18},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl2":"Aside: Taking Command-Line inputs during Python scripts"},"content":"\n\nA useful function when writing scripts is input(). If you include this in your code as follows,var_to_set = input()\nprint(f\"Your input was {var_to_set}\")\n\nyour input will be recored in the variable var_to_set.\n\nExercise Six: Practice accessing Specific Elements in a List\n\nReturn to your program for creating averages from earier. Now, rather than using the list provided called grades, write the program to use input() to populate an empty list with grades (for now, you can just use five lines of input() - we’ll show you how to make ths more automated next week). Then, run the average code over your user-provided list, and print the result in a sentence using an F-string.\n\nAs test case, try inputting [100,100,80,60,60] and verify that your code produces 80.\n\n","type":"content","url":"/variables-datatypes-2025#aside-taking-command-line-inputs-during-python-scripts","position":19},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl2":"The Big Picture: Objects and Functions in Python"},"type":"lvl2","url":"/variables-datatypes-2025#the-big-picture-objects-and-functions-in-python","position":20},{"hierarchy":{"lvl1":"A Deep Dive into Variables and Datatypes","lvl2":"The Big Picture: Objects and Functions in Python"},"content":"\n\nPython is what we call an object-oriented program language. The term objects here refer to bundles of data (attributes) and functions (which often act on that data). The structure of objects (e.g., what functions they contain) is defined by a class; this is why you see the word <class when you run type() on a variable. All Python data types are classes, and by extension, all variables are objects.. For example, let’s take the case of a list:mylist = [5,4]\nmylist.append(5)\n\nHere, mylist is an object of type list, with a value of [5,4]. All objects of type list have a function .append() associated with them. This isn’t true for objects of type int,str, etc -- they have their own functions associated with them since they are each types defined by different classes.\n\nA fun example of a class function associated with int() is as_integer_ratio():var = 3\nprint(var.as_integer_ratio())\n\nAs a general comment, functions are almost always accompanied by a double parantheses(). Anything within those parantheses is called an argument. In the case above, the object itself (var) is an implict argument of the function (as_integer_ratio()).\n\nWe’ll take much more about functions and objects throughout this series, so don’t worry if this is a bit jargon-y and opaque at this point. For now, we will move on to introduce another important datatype called the array.","type":"content","url":"/variables-datatypes-2025#the-big-picture-objects-and-functions-in-python","position":21},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!"},"type":"lvl1","url":"/hunt","position":0},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!"},"content":"","type":"content","url":"/hunt","position":1},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl2":"Introduction"},"type":"lvl2","url":"/hunt#introduction","position":2},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl2":"Introduction"},"content":"Welcome to the Unix Scavenger Hunt! This activity is designed to help you explore and become more comfortable with Unix commands. Each prompt is a mini adventure where you’ll use the terminal to accomplish specific tasks. Feel free to try the challenge in any order!","type":"content","url":"/hunt#introduction","position":3},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl2":"Rules"},"type":"lvl2","url":"/hunt#rules","position":4},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl2":"Rules"},"content":"You can use Google and other resources to find the commands and solutions, but try using man and -h first to see if the documentation makes sense!\n\nMake sure to write down/document the commands you use and what those commands do. We will go around and share what we learned at the end of the class time.\n\nTry to stick to terminal - don’t use your machine’s GUI to get to the solutions!\n\nHave fun and enjoy the exploration!\n\nOne General Tip!\n\nThe man command (stands for manual) prints detailed help information for unix commands and can help you throughout this exercise! You can call up the manual for a command like so: man ls. This opens a vim like editor that you can scroll through (with your mouse or arrow keys depending on your terminal set up). To exit the manual, press q.\n\n","type":"content","url":"/hunt#rules","position":5},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl2":"Scavenger Hunt Challenges"},"type":"lvl2","url":"/hunt#scavenger-hunt-challenges","position":6},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl2":"Scavenger Hunt Challenges"},"content":"We are sharing a folder with all of you via Slack. Everyone should download a copy of this folder onto their machine for this exercise.\n\n","type":"content","url":"/hunt#scavenger-hunt-challenges","position":7},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl3":"Challenge 1: The Hidden Treasure","lvl2":"Scavenger Hunt Challenges"},"type":"lvl3","url":"/hunt#challenge-1-the-hidden-treasure","position":8},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl3":"Challenge 1: The Hidden Treasure","lvl2":"Scavenger Hunt Challenges"},"content":"Find a file named “treasure.txt.” Navigate to it, retrieve the contents of the file, and share what you’ve discovered!\n\nOpen for Hint\n\nHere are some ideas:\n\nConsider the grep command!\n\nYou can use cat, less, or more to view the contents of a file. Like for man, close the opened program by hitting q.\n\nHard Mode: try using an editor like vim or nano to read the file!\n\n","type":"content","url":"/hunt#challenge-1-the-hidden-treasure","position":9},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl3":"Challenge 2: Mysterious Sizes","lvl2":"Scavenger Hunt Challenges"},"type":"lvl3","url":"/hunt#challenge-2-mysterious-sizes","position":10},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl3":"Challenge 2: Mysterious Sizes","lvl2":"Scavenger Hunt Challenges"},"content":"Try to find the directoy with the biggest size in the folder we shared with you. Now try to find the largest individual file. Share the directory name (and/or file name), size, and the command you used to find it.\n\nOpen for Hint\n\nHere are some ideas:\n\nLook into available flags for the ls command\n\nConsider the du command, and play around with which flags you can use!\n\n","type":"content","url":"/hunt#challenge-2-mysterious-sizes","position":11},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl3":"Challenge 3: The Time Traveler","lvl2":"Scavenger Hunt Challenges"},"type":"lvl3","url":"/hunt#challenge-3-the-time-traveler","position":12},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl3":"Challenge 3: The Time Traveler","lvl2":"Scavenger Hunt Challenges"},"content":"Find a file with a modification date that is at least one month ago and change its timestamp!\n\nOpen for Hint\n\nHere are some ideas:\n\nRecall we can us ls -l to view file details\n\nConsider the touch command!\n\n","type":"content","url":"/hunt#challenge-3-the-time-traveler","position":13},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl3":"Challenge 4: The Artist","lvl2":"Scavenger Hunt Challenges"},"type":"lvl3","url":"/hunt#challenge-4-the-artist","position":14},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl3":"Challenge 4: The Artist","lvl2":"Scavenger Hunt Challenges"},"content":"Create a new directory named “masterpiece” and populate it with text files, each containing a line from your favorite quote or poem. Use an editor (either vim or nano, but I recommend vim!) to make your files. Share the commands you used to create and populate the directory.\n\nThen, use a command to print out all your lines of poetry (across the files) one after the other.\n\nOpen for Hint\n\nHere are some ideas:\n\nUtilize commands like mkdir to create folders. You can use vim to generate files!\n\nConsider the cat command to print your poems!\n\nFor printing all lines, there is a way with both grep and head, both of which use the wildcard *!\n\n","type":"content","url":"/hunt#challenge-4-the-artist","position":15},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl3":"Challenge 5: Pipe Explorer","lvl2":"Scavenger Hunt Challenges"},"type":"lvl3","url":"/hunt#challenge-5-pipe-explorer","position":16},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl3":"Challenge 5: Pipe Explorer","lvl2":"Scavenger Hunt Challenges"},"content":"Navigate to a directory containing multiple text files. Use a combination of commands and piping to find and count the number of lines in each text file. Share your results, showing the filename and the corresponding line count for each text file.\n\nOpen for Hint\n\nHere are some ideas:\n\nConsider using find to locate text files and wc -l to count lines.\n\n","type":"content","url":"/hunt#challenge-5-pipe-explorer","position":17},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl2":"Conclusion"},"type":"lvl2","url":"/hunt#conclusion","position":18},{"hierarchy":{"lvl1":"Unix Scavenger Hunt!","lvl2":"Conclusion"},"content":"Remember, the goal is to have fun and gain hands-on experience with Unix commands. Feel free to experiment and explore beyond the prompts. Happy scavenger hunting!","type":"content","url":"/hunt#conclusion","position":19},{"hierarchy":{"lvl1":"Calculating the Luminosities of Stars"},"type":"lvl1","url":"/week1-lab-2025","position":0},{"hierarchy":{"lvl1":"Calculating the Luminosities of Stars"},"content":"Now, we can put together everything we’ve learned so far to build a useful script.  We’ll do so in the context of the properties of stars.\n\n1. The Stefan-Boltzmann Law\n\nStars, to zeroth order, can be considered spherically-symmetric blackbodies. Under those conditions, their luminosities can be computed via the Stefan-Boltzmann law,L = 4\\pi R^2 \\sigma T^4\n\nwhere R is the radius, T is the effective temperature of the Star, and σ is the Stefan-Boltzmann constant, \\sigma = 5.67 * 10^{-8} \\rm \\ W/m^{2}/K^{4}.\n\nThe goal of today’s lab is to implement this in Python, i.e., write a code to calculate the Luminosity (L) of a star according to the formula described above. The rough steps are as follows:\n\nCreate a new code file called “SB.py” using the Terminal.\n\nWithin SB.py, define a unique variable for each of π, σ, R, and T. For now, assume \\pi = 3.14, R = 7 * 10^8 meters and T = 5776 K.  You can assume the units work out (and therefore you can ignore them in Python).\n\nUsing basic mathematical operations, compute the value of L according to the formula above using the variables you just defined. Store the result in a new variable. (Hint: powers in python are implemented via the ** operator, e.g., 6**2 = 36)\n\nUsing f-strings, print the result in a sentence that looks like:\nThe Luminosity of a star with effective temperature [value of T] and radius [value of R] is [value of L].\n\nTest the script by running it from the terminal. Outside of Python, compare your luminosity value to the Solar luminosity, 3.8 * 10^{26} Watts. Is your value greater, less than, or equal to the Solar luminosity?\n\nRather than simply hardcoding the value of T and R in your script, use the input() function to allow you to provide the values in the terminal at runtime.\n\nImplement the comparison to the Solar Luminosity in your code and store the result a new boolean (True/False) variable called supersolar. Then extend your f-string above to print whether the star is more luminous than the Sun. The output should look like: The Luminosity of a star with effective temperature [value of T] and radius [value of R] is [value of L]. It is [value of supersolar] that this is more luminous than the Sun.\n\n2. Practice with List Indexing\n\nLet’s imagine you have data for bright stars that looks a bit like:star_names = [\"Sirius\", \"Canopus\", \"Rigil Kentaurus\", \"Arcturus\", \"Vega\", \"Capella\", \"Rigel\", \"Procyon\", \"Achernar\", \\ \n\"Betelgeuse\", \"Acrux\", \"Altair\", \"Aldebaran\", \"Spica\", \"Antares\", \"Pollux\", \"Fomalhaut\", \"Deneb\", \"Regulus\", \"Adhara\"]\n\nstar_temperatures =  [9940, 7400, 5800, 4300, 9600, 4900, 12100, 6550, 14600, 3500, 28000, 7700, 3900, 22200, 3400, 4940, 8550, 8525, 12300, 20800]\n\nstar_radii = [1.711e9, 7.8e8, 1.227e9, 2.785e9, 2.364e9, 1.192e9, 7.6e8, 7.43e8, 1.586e9, 9.52e10, 6.01e9, 1.656e9, \\ \n4.28e9, 7.739e8, 8.12e9, 1.927e9, 1.834e9, 8.48e9, 3.919e9, 4.66e9]\n\nCreate a new script called star_calcs.py.\n\nUsing indexing, figure out: what the name of the tenth star in this list? Then, store the index in a variable.\n\nNow, using the stored index, isolate the temperature of the star by accessing the appropriate element of the second list.\n\nRepeat step 2 for the radius.\n\nBy copy-pasting your formula implementation from exercise 1 into your new script, compute the luminosity of the star of the tenth star.\n\nNow that we’ve finished with star 10, let’s try to make it our code more generally applicable.\n\nHave your program take an index in via input() and run the calculation for the star corresponding to that index.\n\n(BONUS): Create a dictionary for each of the two properties for the first 5 stars above (that is, a dictionary for radius and a dictionary for temperature). The keys should be the star names.\n\n(BONUS part 2): Now have your program take the star name as an input and print the name, temperature, radius, and computed luminosity in a nicely formatted sentence.","type":"content","url":"/week1-lab-2025","position":1},{"hierarchy":{"lvl1":"Course Topics by Week"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Course Topics by Week"},"content":"\nThis workshop series will focus on an introduction to the Python programming language in the context of physics and astrophysics applications. All research carried in these scientific fields requires the use of extensive programming, making it a bedrock skill of any scientist. In this seminar, we will start from square one, covering how to install and navigate the programming ecosystem such as the terminal/shell, before moving into how to create scientific programs in python to carry out calculations one might use in a research project. This workshop series is primarily intended for students with little to no exposure to coding or astronomy research. After taking this series, students should be prepared to tackle programming-based courses (e.g., ASTR 255/330) as well as feel comfortable applying to summer research positions.\n\nThis series meets twice a week in the afternoon (M/W 5-6). Monday sessions will have (interactive) lectures in which a new programming concept is introduced. Wednesday is a “lab” in which students will work on a weekly assignment targeting those concepts. We expect most students to finish the weekly assignment during the Wednesday session, but they are due the following Tuesday, so time can be taken outside of the seminar if needed.\n\nIf you are interested in participating in the workshop series, please fill out \n\nTHIS INTEREST FORM!","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Course Topics by Week"},"type":"lvl1","url":"/#course-topics-by-week","position":2},{"hierarchy":{"lvl1":"Course Topics by Week"},"content":"Week 1 (Jan 25):\n\nUNIX, filesystems, environments and the Python ecosystem\n\nWeek 2 (Feb 3):\n\nPure Python programming, calculations, variables, datatypes and scripts\n\nWeek 3 (Feb 12):\n\nIntroduction to numpy\n\nControl flow, loops, program logic, and an introduction to libraries\n\nWeek 4 (Feb 19):\n\nFunctions and functional programming\n\nIntroduction to ipython notebooks (jupyter)\n\nWeek 5 (Feb 26):\n\nVectorization and program efficiency\n\nFinal project introductions\n\nWeek 6 (March 4):\n\nWorking with astrophysical datasets (loading, analyzing, fitting, visualizing)\n\nSpring Break\n\nWeek 7 (March 25):\n\nIntroduction to Object Oriented Programming\n\nWeek 8 (April 1):\n\nIntroduction to github and version control + Bonus Content\n\nWeek 9 (April 8):\n\nFinal presentations\n\nFor a more detailed topic list, \n\nclick here","type":"content","url":"/#course-topics-by-week","position":3},{"hierarchy":{"lvl1":"Course Topics"},"type":"lvl1","url":"/topiclist","position":0},{"hierarchy":{"lvl1":"Course Topics"},"content":"UNIX, Filesystems, Environments and the Python Ecosystem\n\nIn this module we will familiarize students with the command line interface of computer operating systems, teach common unix commands, and discuss the installation of environments with Python, and where that is situated in the broader coding ecosystem.\n\nDiscussion of the differences between CS and DS/astronomy analysis\n\nPure Python Programming, Calculations, Variables, Datatypes and Scripts\n\nIn this module, we introduce the basic python syntax, including variable declaration, basic mathematical operations, and the built-in datatypes (+numpy). We will transition from the iPython interpreter to standalone python scripts.3/\n\nControl flow, Loops, Program Logic, and an introduction to Libraries (astropy+matplotlib)\n\nIn this module we will first expand the set of applications by discussing package imports (beyond numpy), including matplotlib and astropy. We will then use relevant examples from these packages to teach program logic and control flow (if/else, try/except) and looping (for/while).\n\nWe will also take time here to discuss the parsing of error messages and how to debug errors in code.\n\nFunctions and Functional Programming, Notebooks\n\nUsing examples from astropy+matplotlib+numpy, we will introduce the creation of user-defined functions in Python, their benefits, and best practices for documentation, including type annotations.\n\nAt this point, we will introduce the concept of jupyter notebooks, how they differ from standard scripts, and common pitfalls. We will provide a framework for development in notebooks by which functions are created and tested and then moved to a python module for import and use.\n\nVectorization, Program Efficiency, and Final Project Introductions\n\nIn this module we will discuss common programming pitfalls that lead to inefficient (slow) code, and we will formally introduce several methods to write code that will run as quickly as possible.\n\nWe will also introduce the final projects and get students thinking about ideas.\n\nWorking with Astrophysical Datasets (Loading, Analyzing, Fitting, Visualizing)\n\nIn this module, we will discuss several different libraries (including pandas) in the context of loading and working with more complex astronomical data (beyond individual fits images or simple two column tables) and different file types (csv, fits, hdf5, json). Additionally, retrieving data from online servers and catalogs (e.g., astroquery and sql).\n\nWe will discuss real statistical analyses one would apply to these data, and demonstrate several ways of carrying out model fits (e.g., with polyfit, spline fits, chi^2 grid searches, or mcmc).\n\nFinally, we will touch on more advanced plotting techniques for “publication” plots and figures which capture rich datasets.\n\nSpring Break (end of regular seminar content/assignments)\n\nIntroduction to Object Oriented Programming\n\nWe return to introductory discussions of objects in python and the OOP paradigm of creating objects with methods and attributes. We will show how to create simple classes that may be useful to students.\nNote there is no explicit lab for this; students are working on their final projects in class.\n\nIntroduction to Github and Version Control + Bonus Content\n\nWe will introduce the students to the basic use of github for version control. This will in turn prepare them to upload their final projects to github.\n\nWe have several “Bonus Content” Topics that we will allow the students to choose from during these last few weeks while the focus is on their final projects. There are no “regular” assignments for these weeks. Topics include:\n\nHTML/CSS and building a personal website\n\nLaTeX typesettings (for papers or homework)\n\nMore OOP discussion\n\nFinal Project Presentations\n\nFinally, we invite the students to present their final project demonstrations to the class. These projects represent several weeks of coding effort. Students are encouraged to choose any topic that interests them; we have had projects spanning the range from implementing a game like chess or battleship, to astronomy themed projects such as writing a simple integrator or simulating galaxy collisions. We will (potentially) be inviting the department at large to attend these presentations.","type":"content","url":"/topiclist","position":1}]}